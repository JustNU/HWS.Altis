RYD_WS_specFor_class =
	[
	];

RYD_WS_recon_class = 
	[
	"o_recon_exp_f",
	"o_recon_f",
	"o_recon_jtac_f",
	"o_recon_lat_f",
	"o_recon_m_f",
	"o_recon_medic_f",
	"o_recon_tl_f",
	"b_recon_exp_f",
	"b_recon_f",
	"b_recon_jtac_f",
	"b_recon_lat_f",
	"b_recon_m_f",
	"b_recon_medic_f",
	"b_recon_tl_f",
	"i_uav_ai",
	"o_uav_ai",
	"b_uav_ai",
	"i_uav_01_f",
	"i_uav_02_cas_f",
	"i_uav_02_f",
	"i_ugv_01_f",
	"i_ugv_01_rcws_f",
	"o_uav_01_f",
	"o_uav_02_cas_f",
	"o_uav_02_f",
	"o_ugv_01_f",
	"o_ugv_01_rcws_f",
	"b_uav_01_f",
	"b_uav_02_cas_f",
	"b_uav_02_f",
	"b_ugv_01_f",
	"b_ugv_01_rcws_f"
	];
	
RYD_WS_FO_class =
	[
	"i_spotter_f",
	"o_spotter_f",
	"b_spotter_f",
	"o_recon_jtac_f",
	"b_recon_jtac_f"
	];
	
RYD_WS_snipers_class = 
	[
	"i_sniper_f",
	"o_sniper_f",
	"b_sniper_f",
	"i_soldier_m_f",
	"o_soldier_m_f",
	"b_g_soldier_m_f",
	"b_soldier_m_f",
	"o_recon_m_f",
	"b_recon_m_f",
	"o_soldieru_m_f"
	];
	
RYD_WS_ATinf_class =
	[
	"i_soldier_at_f",
	"i_soldier_lat_f",
	"o_soldier_at_f",
	"o_soldier_lat_f",
	"b_soldier_at_f",
	"b_soldier_lat_f",
	"b_g_soldier_lat_f",
	"o_soldieru_at_f",
	"o_soldieru_lat_f",
	"o_recon_lat_f",
	"b_ctrg_soldier_gl_lat_f",
	"b_recon_lat_f"
	];

RYD_WS_AAinf_class = 
	[
	"i_soldier_aa_f",
	"b_soldier_aa_f",
	"o_soldier_aa_f",
	"o_apc_tracked_02_aa_f",
	"b_apc_tracked_01_aa_f",
	"o_soldieru_aa_f"
	];

RYD_WS_Inf_class =
	[
	"i_crew_f",
	"i_engineer_f",
	"i_helicrew_f",
	"i_helipilot_f",
	"i_medic_f",
	"i_officer_f",
	"i_pilot_f",
	"i_soldier_a_f",
	"i_soldier_aa_f",
	"i_soldier_ar_f",
	"i_soldier_at_f",
	"i_soldier_exp_f",
	"i_soldier_f",
	"i_soldier_gl_f",
	"i_soldier_lat_f",
	"i_soldier_lite_f",
	"i_soldier_m_f",
	"i_soldier_repair_f",
	"i_soldier_sl_f",
	"i_soldier_tl_f",
	"i_soldier_uav_f",
	"o_crew_f",
	"o_engineer_f",
	"o_helicrew_f",
	"o_helipilot_f",
	"o_medic_f",
	"o_officer_f",
	"o_pilot_f",
	"o_soldier_a_f",
	"o_soldier_aa_f",
	"o_soldier_ar_f",
	"o_soldier_at_f",
	"o_soldier_exp_f",
	"o_soldier_f",
	"o_soldier_gl_f",
	"o_soldier_lat_f",
	"o_soldier_lite_f",
	"o_soldier_m_f",
	"o_soldier_pg_f",
	"o_soldier_repair_f",
	"o_soldier_sl_f",
	"o_soldier_tl_f",
	"o_soldier_uav_f",
	"b_g_engineer_f",
	"b_g_medic_f",
	"b_g_officer_f",
	"b_g_soldier_a_f",
	"b_g_soldier_ar_f",
	"b_g_soldier_exp_f",
	"b_g_soldier_f",
	"b_g_soldier_gl_f",
	"b_g_soldier_lat_f",
	"b_g_soldier_lite_f",
	"b_g_soldier_m_f",
	"b_g_soldier_sl_f",
	"b_g_soldier_tl_f",
	"b_g_survivor_f",
	"b_crew_f",
	"b_engineer_f",
	"b_helicrew_f",
	"b_helipilot_f",
	"b_medic_f",
	"b_officer_f",
	"b_pilot_f",
	"b_soldier_a_f",
	"b_soldier_aa_f",
	"b_soldier_ar_f",
	"b_soldier_at_f",
	"b_soldier_exp_f",
	"b_soldier_f",
	"b_soldier_gl_f",
	"b_soldier_lat_f",
	"b_soldier_lite_f",
	"b_soldier_m_f",
	"b_soldier_pg_f",
	"b_soldier_repair_f",
	"b_soldier_sl_f",
	"b_soldier_tl_f",
	"b_soldier_uav_f",
	"o_recon_exp_f",
	"o_recon_f",
	"o_recon_jtac_f",
	"o_recon_lat_f",
	"o_recon_m_f",
	"o_recon_medic_f",
	"o_recon_tl_f",
	"b_recon_exp_f",
	"b_recon_f",
	"b_recon_jtac_f",
	"b_recon_lat_f",
	"b_recon_m_f",
	"b_recon_medic_f",
	"b_recon_tl_f",
	"i_sniper_f",
	"i_spotter_f",
	"o_sniper_f",
	"o_spotter_f",
	"b_sniper_f",
	"b_spotter_f",
	"o_engineer_u_f",
	"o_soldieru_a_f",
	"o_soldieru_aa_f",
	"o_soldieru_aaa_f",
	"o_soldieru_aar_f",
	"o_soldieru_aat_f",
	"o_soldieru_ar_f",
	"o_soldieru_at_f",
	"o_soldieru_exp_f",
	"o_soldieru_f",
	"o_soldieru_gl_f",
	"o_soldieru_lat_f",
	"o_soldieru_m_f",
	"o_soldieru_medic_f",
	"o_soldieru_repair_f",
	"o_soldieru_sl_f",
	"o_soldieru_tl_f",
	"i_soldier_aaa_f",
	"i_soldier_aar_f",
	"i_soldier_aat_f",
	"i_support_amg_f",
	"i_support_amort_f",
	"i_support_gmg_f",
	"i_support_mg_f",
	"i_support_mort_f",
	"o_soldier_aaa_f",
	"o_soldier_aar_f",
	"o_soldier_aat_f",
	"o_support_amg_f",
	"o_support_amort_f",
	"o_support_gmg_f",
	"o_support_mg_f",
	"o_support_mort_f",
	"b_soldier_aaa_f",
	"b_soldier_aar_f",
	"b_soldier_aat_f",
	"b_support_amg_f",
	"b_support_amort_f",
	"b_support_gmg_f",
	"b_support_mg_f",
	"b_support_mort_f",
	"i_diver_exp_f",
	"i_diver_f",
	"i_diver_tl_f",
	"o_diver_exp_f",
	"o_diver_f",
	"o_diver_tl_f",
	"b_diver_exp_f",
	"b_diver_f",
	"b_diver_tl_f",
	"i_story_colonel_f",
	"o_story_ceo_f",
	"o_story_colonel_f",
	"i_g_story_protagonist_f",
	"b_competitor_f",
	"b_rangemaster_f",
	"b_story_colonel_f",
	"b_story_engineer_f",
	"b_story_pilot_f",
	"b_story_protagonist_f",
	"b_story_sf_captain_f",
	"b_story_tank_commander_f",
	"b_ctrg_soldier_engineer_exp_f",
	"b_ctrg_soldier_m_medic_f",
	"b_ctrg_soldier_ar_a_f",
	"b_ctrg_soldier_gl_lat_f",
	"i_g_story_sf_captain_f",
	"i_g_resistancecommander_f",
	"i_g_resistanceleader_f"
	];
	
RYD_WS_Art_class = 
	[
	"b_mbt_01_arty_f",
	"o_mbt_02_arty_f",
	"b_mbt_01_mlrs_f",
	"i_mortar_01_f",
	"o_mortar_01_f",
	"b_g_mortar_01_f",
	"b_mortar_01_f"
	];
	
RYD_WS_HArmor_class = 
	[
	"b_mbt_01_cannon_f",
	"b_mbt_01_tusk_f",
	"o_mbt_02_cannon_f",
	"i_mbt_03_cannon_f"
	];
	
RYD_WS_MArmor_class = 
	[
	];

RYD_WS_LArmor_class = 
	[
	"i_apc_wheeled_03_cannon_f",
	"o_apc_tracked_02_aa_f",
	"o_apc_tracked_02_cannon_f",
	"o_apc_wheeled_02_rcws_f",
	"b_apc_tracked_01_aa_f",
	"b_apc_tracked_01_rcws_f",
	"b_apc_wheeled_01_cannon_f",
	"i_apc_tracked_03_cannon_f"
	];
	
RYD_WS_LArmorAT_class =
	[
	"b_apc_wheeled_01_cannon_f",
	"i_apc_wheeled_03_cannon_f",
	"o_apc_tracked_02_cannon_f",
	"i_apc_tracked_03_cannon_f"
	];

RYD_WS_Cars_class =
	[
	"i_mrap_03_f",
	"i_mrap_03_gmg_f",
	"i_mrap_03_hmg_f",
	"i_quadbike_01_f",
	"i_truck_02_covered_f",
	"i_truck_02_transport_f",
	"o_mrap_02_f",
	"o_mrap_02_gmg_f",
	"o_mrap_02_hmg_f",
	"o_quadbike_01_f",
	"o_truck_02_covered_f",
	"o_truck_02_transport_f",
	"o_truck_03_device_f",
	"o_truck_03_transport_f",
	"o_truck_03_covered_f",
	"b_g_offroad_01_armed_f",
	"b_g_offroad_01_f",
	"b_g_quadbike_01_f",
	"b_g_van_01_transport_f",
	"b_g_offroad_01_repair_f",
	"b_mrap_01_f",
	"b_mrap_01_gmg_f",
	"b_mrap_01_hmg_f",
	"b_quadbike_01_f",
	"b_truck_01_box_f",
	"b_truck_01_covered_f",
	"b_truck_01_mover_f",
	"b_truck_01_transport_f",
	"i_truck_02_ammo_f",
	"i_truck_02_box_f",
	"i_truck_02_fuel_f",
	"i_truck_02_medical_f",
	"o_truck_02_ammo_f",
	"o_truck_02_box_f",
	"o_truck_02_fuel_f",
	"o_truck_02_medical_f",
	"b_g_van_01_fuel_f",
	"b_truck_01_ammo_f",
	"b_truck_01_repair_f",
	"b_truck_01_fuel_f",
	"b_truck_01_medical_f",
	"o_truck_03_ammo_f",
	"o_truck_03_fuel_f",
	"o_truck_03_medical_f",
	"o_truck_03_repair_f",
	"i_ugv_01_f",
	"i_ugv_01_rcws_f",
	"o_ugv_01_f",
	"o_ugv_01_rcws_f",
	"b_ugv_01_f",
	"b_ugv_01_rcws_f"
	];
	
RYD_WS_Air_class = 
	[
	"i_heli_transport_02_f",
	"i_plane_fighter_03_aa_f",
	"i_plane_fighter_03_cas_f",
	"b_plane_cas_01_f",
	"o_plane_cas_02_f",
	"o_heli_attack_02_black_f",
	"o_heli_attack_02_f",
	"o_heli_light_02_f",
	"o_heli_light_02_unarmed_f",
	"b_heli_attack_01_f",
	"b_heli_light_01_armed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"i_uav_ai",
	"o_uav_ai",
	"b_uav_ai",
	"i_uav_01_f",
	"i_uav_02_cas_f",
	"i_uav_02_f",
	"o_uav_01_f",
	"o_uav_02_cas_f",
	"o_uav_02_f",
	"b_uav_01_f",
	"b_uav_02_cas_f",
	"b_uav_02_f",
	"i_heli_light_03_f",
	"i_heli_light_03_unarmed_f"
	];
	
RYD_WS_Air_class_B = 
	[
	//"b_plane_cas_01_f",
	"b_heli_attack_01_f",
	"b_heli_light_01_armed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f"
	];
	
RYD_WS_Air_class_O = 
	[
	//"o_plane_cas_02_f",
	"o_heli_attack_02_black_f",
	"o_heli_attack_02_f",
	"o_heli_light_02_f",
	"o_heli_light_02_unarmed_f"
	];
	
RYD_WS_Air_class_I = 
	[
	"i_heli_transport_02_f",
	//"i_plane_fighter_03_aa_f",
	//"i_plane_fighter_03_cas_f",
	"i_heli_light_03_f",
	"i_heli_light_03_unarmed_f"
	];
	
RYD_WS_BAir_class = 
	[
	"i_plane_fighter_03_cas_f",
	"b_plane_cas_01_f",
	"o_plane_cas_02_f"
	];
	
RYD_WS_RAir_class = 
	[
	"i_uav_01_f",
	"i_uav_02_cas_f",
	"i_uav_02_f",
	"o_uav_01_f",
	"o_uav_02_cas_f",
	"o_uav_02_f",
	"b_uav_01_f",
	"b_uav_02_cas_f",
	"b_uav_02_f"
	];
	
RYD_WS_NCAir_class = 
	[
	"i_heli_transport_02_f",
	"o_heli_light_02_unarmed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"i_heli_light_03_unarmed_f",
	"i_uav_01_f",
	"i_uav_02_f",
	"o_uav_01_f",
	"o_uav_02_f",
	"b_uav_01_f",
	"b_uav_02_f"	
	];

RYD_WS_Naval_class = 
	[
	"i_boat_armed_01_minigun_f",
	"i_boat_transport_01_f",
	"o_boat_armed_01_hmg_f",
	"o_boat_transport_01_f",
	"o_lifeboat",
	"b_g_boat_transport_01_f",
	"b_boat_armed_01_minigun_f",
	"b_boat_transport_01_f",
	"b_lifeboat",
	"i_sdv_01_f",
	"o_sdv_01_f",
	"b_sdv_01_f"	
	];
	
RYD_WS_Static_class = 
	[
	"i_gmg_01_a_f",
	"i_gmg_01_f",
	"i_gmg_01_high_f",
	"i_hmg_01_a_f",
	"i_hmg_01_f",
	"i_hmg_01_high_f",
	"i_mortar_01_f",
	"i_static_aa_f",
	"i_static_at_f",
	"o_gmg_01_a_f",
	"o_gmg_01_f",
	"o_gmg_01_high_f",
	"o_hmg_01_a_f",
	"o_hmg_01_f",
	"o_hmg_01_high_f",
	"o_mortar_01_f",
	"o_static_aa_f",
	"o_static_at_f",
	"b_g_mortar_01_f",
	"b_gmg_01_a_f",
	"b_gmg_01_f",
	"b_gmg_01_high_f",
	"b_hmg_01_a_f",
	"b_hmg_01_f",
	"b_hmg_01_high_f",
	"b_mortar_01_f",
	"b_static_aa_f",
	"b_static_at_f"
	];
	
RYD_WS_Static_class_B = 
	[
	"b_g_mortar_01_f",
	"b_gmg_01_a_f",
	"b_gmg_01_f",
	"b_gmg_01_high_f",
	"b_hmg_01_a_f",
	"b_hmg_01_f",
	"b_hmg_01_high_f",
	"b_mortar_01_f",
	"b_static_aa_f",
	"b_static_at_f"
	];
	
RYD_WS_Static_class_O = 
	[
	"o_gmg_01_a_f",
	"o_gmg_01_f",
	"o_gmg_01_high_f",
	"o_hmg_01_a_f",
	"o_hmg_01_f",
	"o_hmg_01_high_f",
	"o_mortar_01_f",
	"o_static_aa_f",
	"o_static_at_f"
	];
	
RYD_WS_Static_class_I = 
	[
	"i_gmg_01_a_f",
	"i_gmg_01_f",
	"i_gmg_01_high_f",
	"i_hmg_01_a_f",
	"i_hmg_01_f",
	"i_hmg_01_high_f",
	"i_mortar_01_f",
	"i_static_aa_f",
	"i_static_at_f"
	];
	
RYD_WS_StaticAA_class =
	[
	"i_static_aa_f",
	"o_static_aa_f",
	"b_static_aa_f"
	];
	
RYD_WS_StaticAT_class =
	[
	"i_static_at_f",
	"o_static_at_f",
	"b_static_at_f"
	];
	
RYD_WS_Support_class =
	[
	"i_truck_02_ammo_f",
	"i_truck_02_box_f",
	"i_truck_02_fuel_f",
	"i_truck_02_medical_f",
	"o_truck_02_ammo_f",
	"o_truck_02_box_f",
	"o_truck_02_fuel_f",
	"o_truck_02_medical_f",
	"o_truck_03_ammo_f",
	"o_truck_03_fuel_f",
	"o_truck_03_medical_f",
	"o_truck_03_repair_f",
	"b_g_van_01_fuel_f",
	"b_g_offroad_01_repair_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_ammo_f",
	"b_truck_01_repair_f",
	"b_truck_01_fuel_f",
	"b_truck_01_medical_f"
	];
	
RYD_WS_Support_class_B =
	[
	"b_g_van_01_fuel_f",
	"b_g_offroad_01_repair_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_ammo_f",
	"b_truck_01_repair_f",
	"b_truck_01_fuel_f",
	"b_truck_01_medical_f"
	];
	
RYD_WS_Support_class_O =
	[
	"o_truck_02_ammo_f",
	"o_truck_02_box_f",
	"o_truck_02_fuel_f",
	"o_truck_02_medical_f",
	"o_truck_03_ammo_f",
	"o_truck_03_fuel_f",
	"o_truck_03_medical_f",
	"o_truck_03_repair_f"
	];
	
RYD_WS_Support_class_I =
	[
	"i_truck_02_ammo_f",
	"i_truck_02_box_f",
	"i_truck_02_fuel_f",
	"i_truck_02_medical_f"
	];
	
RYD_WS_Cargo_class =
	[
	"i_heli_transport_02_f",
	"o_heli_attack_02_black_f",
	"o_heli_attack_02_f",
	"o_heli_light_02_f",
	"o_heli_light_02_unarmed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"i_truck_02_medical_f",
	"o_truck_02_medical_f",
	"b_truck_01_medical_f",
	"o_truck_03_medical_f",
	"i_boat_armed_01_minigun_f",
	"i_boat_transport_01_f",
	"o_boat_armed_01_hmg_f",
	"o_boat_transport_01_f",
	"o_lifeboat",
	"b_g_boat_transport_01_f",
	"b_boat_armed_01_minigun_f",
	"b_boat_transport_01_f",
	"b_lifeboat",
	"i_sdv_01_f",
	"o_sdv_01_f",
	"b_sdv_01_f",
	"b_mbt_01_cannon_f",
	"i_apc_wheeled_03_cannon_f",
	"o_apc_tracked_02_cannon_f",
	"o_apc_wheeled_02_rcws_f",
	"b_apc_tracked_01_rcws_f",
	"b_apc_wheeled_01_cannon_f",
	"i_mrap_03_f",
	"i_mrap_03_gmg_f",
	"i_mrap_03_hmg_f",
	"i_quadbike_01_f",
	"i_truck_02_covered_f",
	"i_truck_02_transport_f",
	"o_mrap_02_f",
	"o_mrap_02_gmg_f",
	"o_mrap_02_hmg_f",
	"o_quadbike_01_f",
	"o_truck_02_covered_f",
	"o_truck_02_transport_f",
	"o_truck_03_device_f",
	"o_truck_03_transport_f",
	"o_truck_03_covered_f",
	"b_g_offroad_01_armed_f",
	"b_g_offroad_01_f",
	"b_g_quadbike_01_f",
	"b_g_van_01_transport_f",
	"b_mrap_01_f",
	"b_mrap_01_gmg_f",
	"b_mrap_01_hmg_f",
	"b_quadbike_01_f",
	"b_truck_01_box_f",
	"b_truck_01_covered_f",
	"b_truck_01_mover_f",
	"b_truck_01_transport_f",
	"i_heli_light_03_f",
	"i_heli_light_03_unarmed_f",
	"i_apc_tracked_03_cannon_f"	
	];
	
RYD_WS_NCCargo_class = 
	[
	"i_heli_transport_02_f",
	"o_heli_light_02_unarmed_f",
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"i_heli_light_03_unarmed_f",
	"i_truck_02_medical_f",
	"o_truck_02_medical_f",
	"b_truck_01_medical_f",
	"o_truck_03_medical_f",
	"i_boat_transport_01_f",
	"o_boat_transport_01_f",
	"o_lifeboat",
	"b_g_boat_transport_01_f",
	"b_boat_transport_01_f",
	"b_lifeboat",
	"i_mrap_03_f",
	"i_quadbike_01_f",
	"i_truck_02_covered_f",
	"i_truck_02_transport_f",
	"o_mrap_02_f",
	"o_quadbike_01_f",
	"o_truck_02_covered_f",
	"o_truck_02_transport_f",
	"o_truck_03_device_f",
	"o_truck_03_transport_f",
	"o_truck_03_covered_f",
	"b_g_offroad_01_f",
	"b_g_quadbike_01_f",
	"b_g_van_01_transport_f",
	"b_mrap_01_f",
	"b_quadbike_01_f",
	"b_truck_01_box_f",
	"b_truck_01_covered_f",
	"b_truck_01_mover_f",
	"b_truck_01_transport_f"	
	];
	
RYD_WS_NCCargo_class_B = 
	[
	"b_heli_light_01_f",
	"b_heli_transport_01_camo_f",
	"b_heli_transport_01_f",
	"b_g_offroad_01_f",
	"b_g_van_01_transport_f",
	"b_mrap_01_f",
	"b_truck_01_box_f",
	"b_truck_01_covered_f",
	"b_truck_01_mover_f",
	"b_truck_01_transport_f"	
	];
	
RYD_WS_NCCargo_class_I = 
	[
	"i_heli_transport_02_f",
	"i_heli_light_03_unarmed_f",
	"i_mrap_03_f",
	"i_truck_02_covered_f",
	"i_truck_02_transport_f"	
	];
	
RYD_WS_NCCargo_class_O = 
	[
	"o_heli_light_02_unarmed_f",
	"o_mrap_02_f",
	"o_truck_02_covered_f",
	"o_truck_02_transport_f",
	"o_truck_03_transport_f",
	"o_truck_03_covered_f"	
	];
	
RYD_WS_Crew_class =
	[
	"i_crew_f",
	"i_helicrew_f",
	"i_helipilot_f",
	"i_pilot_f",
	"o_crew_f",
	"o_helicrew_f",
	"o_helipilot_f",
	"o_pilot_f",
	"b_crew_f",
	"b_helicrew_f",
	"b_helipilot_f",
	"b_pilot_f",
	"b_story_pilot_f"
	];
	
RYD_WS_Other_class = 
	[
	"i_uav_ai",
	"o_uav_ai",
	"b_uav_ai"	
	];
	
RYD_WS_rep =
	[
	"o_truck_03_repair_f",
	"i_truck_02_box_f",
	"o_truck_02_box_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_repair_f",
	"b_g_offroad_01_repair_f"
	];
	
RYD_WS_med = 
	[
	"o_truck_03_medical_f",
	"i_truck_02_medical_f",
	"o_truck_02_medical_f",
	"b_truck_01_medical_f"
	];
	
RYD_WS_fuel =
	[
	"o_truck_03_fuel_f",
	"i_truck_02_fuel_f",
	"o_truck_02_fuel_f",
	"b_g_van_01_fuel_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_fuel_f"
	];
	
RYD_WS_ammo = 
	[
	"o_truck_03_ammo_f",
	"i_truck_02_ammo_f",
	"o_truck_02_ammo_f",
	"b_apc_tracked_01_crv_f",
	"b_truck_01_ammo_f"
	];
	
RYD_WS_AllClasses = RYD_WS_Inf_class + RYD_WS_Art_class + RYD_WS_HArmor_class + RYD_WS_MArmor_class + RYD_WS_LArmor_class + RYD_WS_Cars_class + RYD_WS_Air_class + RYD_WS_Naval_class + RYD_WS_Static_class + RYD_WS_Support_class + RYD_WS_Other_class;			
	
RHQ_SpecFor = [];
RHQ_Recon = [];
RHQ_FO = [];
RHQ_Snipers = [];
RHQ_ATInf = [];
RHQ_AAInf = [];
RHQ_Inf = [];
RHQ_Art = [];
RHQ_HArmor = [];
RHQ_LArmor = [];
RHQ_LArmorAT = [];
RHQ_Cars = [];
RHQ_Air = [];
RHQ_NCAir = [];
RHQ_Naval = [];
RHQ_Static = [];
RHQ_StaticAA = [];
RHQ_StaticAT = [];
RHQ_Support = [];
RHQ_Cargo = [];
RHQ_NCCargo = [];
RHQ_Other = [];
RHQ_Crew = [];
RHQ_MArmor = [];
RHQ_BAir = [];
RHQ_RAir = [];
RHQ_Ammo = [];
RHQ_Fuel = [];
RHQ_Med = [];
RHQ_Rep = [];

RYD_WS_B_Infantry_G = [];
RYD_WS_B_Motorized_G = [];
RYD_WS_B_Mechanized_G = [];
RYD_WS_B_Armored_G = [];
RYD_WS_B_Air_G = [];
RYD_WS_B_Air_G2 = [];
RYD_WS_B_Static_G2 = [];
RYD_WS_B_Support_G2 = [];
RYD_WS_B_NCCargo_G2 = [];
RYD_WS_B_Officers_G2 = [];

RYD_WS_I_Infantry_G = [];
RYD_WS_I_Motorized_G = [];
RYD_WS_I_Mechanized_G = [];
RYD_WS_I_Armored_G = [];
RYD_WS_I_Air_G = [];
RYD_WS_I_Air_G2 = [];
RYD_WS_I_Static_G2 = [];
RYD_WS_I_Support_G2 = [];
RYD_WS_I_NCCargo_G2 = [];
RYD_WS_I_Officers_G2 = [];

RYD_WS_O_Infantry_G = [];
RYD_WS_O_Motorized_G = [];
RYD_WS_O_Mechanized_G = [];
RYD_WS_O_Armored_G = [];
RYD_WS_O_Air_G = [];
RYD_WS_O_Air_G2 = [];
RYD_WS_O_Static_G2 = [];
RYD_WS_O_Support_G2 = [];
RYD_WS_O_NCCargo_G2 = [];
RYD_WS_O_Officers_G2 = [];

RydHQ_Add_OtherArty = [];

RYD_WS_DynamicRHQ = 
	{
	_gpClass = configFile >> "CfgGroups";
	_vehClass = configFile >> "CfgVehicles";

	for "_i" from 0 to ((count _gpClass) - 1) do
		{
		_class = _gpClass select _i;
		
		if (isClass _class) then
			{
			_side = configName _class;
			_rSide = east;
			
			switch (toLower _side) do
				{
				case ("east") : {_rSide = east};
				case ("west") : {_rSide = west};
				case ("indep") : {_rSide = resistance};
				default {_rSide = civilian};
				};
				
			if (_rSide == civilian) exitWith {};	

			_path = _gpClass >> _side;
			
			for "_j" from 0 to ((count _path) - 1) do
				{
				_class = _path select _j;
				
				if (isClass _class) then
					{
					_fc = configName _class;
					_myFac = _fc;
					
					_path2 = _path >> _fc;
					
					for "_k" from 0 to ((count _path2) - 1) do
						{
						_class = _path2 select _k;
				
						if (isClass _class) then
							{
							_kind = configName _class;
							
							_path3 = _path2 >> _kind;
							
							for "_l" from 0 to ((count _path3) - 1) do
								{
								_class = _path3 select _l;
								
								if (isClass _class) then
									{
									_gp = configName _class;
									
									_path4 = _path3 >> _gp;
									
									_name = getText (_path4 >> "name");
									if ((toLower _name) in ["diver team"]) exitWith {};
									
									_cnt = count _path4;
									_gpType = "inf";
									_typeC = false;
									_vehs = [];
									_isArty = false;
									
									for "_m" from 0 to (_cnt - 1) do
										{
										_type = "inf";
										_class = _path4 select _m;
										
										if (isClass _class) then
											{
											_unit = configName _class;
											
											_veh = _path4 >> _unit >> "vehicle";
											
											if (isText _veh) then
												{
												_veh = toLower (getText _veh);
												_base = _veh;
												_wrong = false;
												
												while {not (_base in ["air","ship","tank","car","wheeled_apc_f","ugv_01_base_f"])} do
													{
													_base = inheritsFrom (_vehClass >> _base);
													if not (isClass _base) exitWith {};
													_base = toLower (configName _base);
													if (_base in ["allvehicles","all"]) exitWith {};
													};

												if (_base in ["ugv_01_base_f"]) then {_wrong = true;_gpType = "ugv_01_base_f"};
													
												if not (_wrong) then
													{
													if (_base in ["air","ship","tank","car","wheeled_apc_f"]) then
														{
														_type = _base
														};
														
													if not (_typeC) then
														{
														if not (_type in ["inf"]) then
															{
															_gpType = _type;
															_typeC = true
															}
														};
														
													_vehClass2 = configfile >> "CfgVehicles" >> _veh;
													
													_myFac = getText (_vehClass2 >> "faction");
														
													if ((getNumber (_vehClass2 >> "artilleryScanner")) > 0) then
														{
														_isArty = true
														};
														
													if not (_veh in RYD_WS_AllClasses) then
														{
														RYD_WS_AllClasses set [(count RYD_WS_AllClasses),_veh];
														
														_turrets = _vehClass2 >> "Turrets";
														
														switch (_type) do
															{
															case ("inf") : 
																{
																RHQ_Inf set [(count RHQ_Inf),_veh];

																if ((getNumber (_vehClass2 >> "camouflage")) < 1) then
																	{
																	if ((toLower (getText (_vehClass2 >> "textSingular"))) in ["sniper"]) then
																		{
																		RHQ_Snipers set [(count RHQ_Snipers),_veh]
																		}
																	else
																		{
																		_weapons = getArray (_vehClass2 >> "weapons");
																		
																		RHQ_Recon set [(count RHQ_Recon),_veh];
																		
																		_hasLaserD = false;
																		
																			{
																			_wpClass = configFile >> "CfgWeapons" >> _x;
																			_type = getNumber (_wpClass >> "type");
																			
																			if (_type == 4096) then
																				{
																				_cursor = toLower (getText (_wpClass >> "cursor"));
																				if (_cursor in ["","emptycursor"]) then 
																					{
																					_cursor = toLower (getText (_wpClass >> "cursorAim"))
																					};

																				if (_cursor in ["laserdesignator"]) exitWith {_hasLaserD = true}
																				};
																				
																			if (_hasLaserD) exitWith {}
																			}
																		foreach _weapons;
																		
																		if (_hasLaserD) then
																			{
																			RHQ_FO set [(count RHQ_FO),_veh]
																			}
																		}
																	};
																	
																if ((toLower ((getText (_vehClass2 >> "textSingular")))) in ["at soldier"]) then
																	{
																	_isAT = true;
																	_weaponsArr = if (isArray (_vehClass2 >> "Weapons")) then
																		{
																		getArray (_vehClass2 >> "Weapons")
																		}
																	else
																		{
																		[]
																		};
																
																	_weaponsArr =	_weaponsArr - ["Throw","Put"];
																	
																	if ((count _weaponsArr) > 1) then
																		{
																		_sWeapon = _weaponsArr select 1;
																		if (isArray (configfile >> "CfgWeapons" >> _sWeapon >> "magazines")) then
																			{
																			_mags = (getArray (configfile >> "CfgWeapons" >> _sWeapon >> "magazines"));
																			if ((count _mags) > 0) then
																				{
																				_mag = (_mags select 0);
																				
																				if (isText (configfile >> "CfgMagazines" >> _mag >> "ammo")) then
																					{
																					_ammo = getText (configfile >> "CfgMagazines" >> _mag >> "ammo");
																					
																					if (isNumber (configfile >> "CfgAmmo" >> _ammo >> "airLock")) then
																						{
																						_isAT = (getNumber (configfile >> "CfgAmmo" >> _ammo >> "airLock")) < 1;
																						}
																					};
																				};
																			};
																		};
																	
																	if (_isAT) then 
																		{
																		RHQ_ATInf set [(count RHQ_ATInf),_veh]
																		} 
																	else 
																		{
																		RHQ_AAInf set [(count RHQ_AAInf),_veh]
																		};
																	
																	}
																};
																
															case ("car") : {RHQ_Cars set [(count RHQ_Cars),_veh]};	
															case ("tank") : {RHQ_HArmor set [(count RHQ_HArmor),_veh]};	
															case ("wheeled_apc_f") : {RHQ_LArmor set [(count RHQ_LArmor),_veh]};
															case ("air") : 
																{
																RHQ_Air set [(count RHQ_Air),_veh];
																if ((((count _turrets) + (count ((getArray (_vehClass2 >> "Weapons")) - ["CMFlareLauncher"]))) < 1)) then
																	{
																	RHQ_NCAir set [(count RHQ_NCAir),_veh];
																	};
																	
																_isUAV = (getNumber (_vehClass2 >> "Uav")) > 0;
																	
																if (_isUAV) then
																	{
																	RHQ_RAir set [(count RHQ_RAir),_veh]
																	}
																};
																
															case ("ship") : {RHQ_Naval set [(count RHQ_Naval),_veh]};
															};
															
														if not (_type in ["inf"]) then
															{
															_vehs set [(count _vehs),_veh];
															
															_mainT = _turrets >> "MainTurret";
															_isMainT = isClass _mainT;
															
															if ((getNumber (_vehClass2 >> "transportSoldier")) > 1) then 
																{
																RHQ_Cargo set [(count RHQ_Cargo),_veh];
																if not (_isMainT) then
																	{
																	RHQ_NCCargo set [(count RHQ_NCCargo),_veh];
																	}
																};
																
															if ((getNumber (_vehClass2 >> "artilleryScanner")) > 0) then
																{
																RHQ_Art set [(count RHQ_Art),_veh];
																
																_prim = "";
																_rare = "";
																_sec = "";
																_smoke = "";
																_illum = "";

																if (_isMainT) then
																	{
																	_mags = getArray (_mainT >> "magazines");
																	_maxHit = 10;
																	
																		{
																		_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
																		_ammoC = configfile >> "CfgAmmo" >> _ammo;
																		
																		_actHit = getNumber (_ammoC >> "indirectHit");
																		
																		if (_actHit > _maxHit) then
																			{
																			_maxHit = _actHit;
																			_prim = _x
																			}
																		}
																	foreach _mags;
																	
																	_mags = _mags - [_prim];
																	_mags0 = +_mags;
																	_illumChosen = false;
																	_smokeChosen = false;
																	_rareChosen = false;
																	_secChosen = false;
																	
																		{
																		_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
																		_ammoC = configfile >> "CfgAmmo" >> _ammo;
																		
																		_hit = getNumber (_ammoC >> "indirectHit");
																		_lc = _ammoC >> "lightColor";
																		_sim = toLower (getText (_ammoC >> "simulation"));
																		_subM = toLower (getText (_ammoC >> "submunitionAmmo"));
																		
																		if (_hit <= 10) then
																			{
																			if not (_subM in [""]) then
																				{
																				_ammoC = configfile >> "CfgAmmo" >> _subM;
																				_hit = getNumber (_ammoC >> "indirectHit")
																				}
																			};

																		switch (true) do
																			{
																			case ((isArray _lc) and not (_illumChosen)) : 
																				{
																				_illum = _x;
																				_mags = _mags - [_x];
																				_illumChosen = true
																				};
																				
																			case ((_hit <= 10) and (_subM in ["smokeshellarty"]) and not (_smokeChosen)) : 
																				{
																				_smoke = _x;
																				_mags = _mags - [_x];
																				_smokeChosen = true
																				};
																				
																			case ((_sim in ["shotsubmunitions"]) and not (_rareChosen)) : 
																				{
																				_rare = _x;
																				_mags = _mags - [_x];
																				_rareChosen = true
																				};
																				
																			case ((_hit > 10) and not ((_secChosen) or (_rare == _x)))  : 
																				{
																				_sec = _x;
																				_mags = _mags - [_x];
																				_secChosen = true
																				}
																			}
																		}
																	foreach _mags0;
																	
																	if (_sec in [""]) then
																		{
																		_maxHit = 10;
																		
																			{
																			_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
																			_ammoC = configfile >> "CfgAmmo" >> _ammo;
																			_subAmmo = _ammoC >> "subMunitionAmmo";

																			if ((isText _subAmmo) and {not ((getText _subAmmo) in [""])}) then
																				{
																				_ammoC = configfile >> "CfgAmmo" >> (getText _subAmmo);
																				};
																				
																			_actHit = getNumber (_ammoC >> "indirectHit");
																			
																			if (_actHit > _maxHit) then
																				{
																				_maxHit = _actHit;
																				_sec = _x
																				}
																			}
																		foreach _mags;
																		}
																	};
																	
																_arr = [_prim,_rare,_sec,_smoke,_illum];
																if (({_x in [""]} count _arr) < 5) then
																	{
																	RydHQ_Add_OtherArty set [(count RydHQ_Add_OtherArty),[[_veh],_arr]]
																	}
																};
																
															RHQ_HArmor = RHQ_HArmor - RHQ_Art;

															if (_isMainT) then
																{
																_mags = getArray (_mainT >> "magazines");
																
																	{
																	_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
																	_ammoC = configfile >> "CfgAmmo" >> _ammo;
																	
																	_isAA = (getNumber (_ammoC >> "airLock")) > 1;
																	_isAT = ((((getNumber (_ammoC >> "irLock")) + (getNumber (_ammoC >> "laserLock"))) > 0) and ((getNumber (_ammoC >> "airLock")) < 2));
																	
																	if (_isAA) then {RHQ_AAInf set [(count RHQ_AAInf),_veh]};
																	if (_isAT) then 
																		{
																		if (_type in ["wheeled_apc_f"]) then
																			{
																			RHQ_LArmorAT set [(count RHQ_LArmorAT),_veh]
																			}
																		else
																			{
																			if (_type in ["car"]) then
																				{
																				RHQ_ATInf set [(count RHQ_ATInf),_veh]
																				}
																			}
																		};
																		
																	if ((_isAA) or (_isAT)) exitWith {}
																	}
																foreach _mags
																}
															}
														}	
													}
												}
											}
										};
																				
										{
										_crew = _vehClass >> _x >> "crew";
										
										if (isText _crew) then
											{
											_crew = toLower (getText _crew);

											if not (_crew in (RYD_WS_Inf_class + RHQ_Inf)) then
												{
												RYD_WS_AllClasses set [(count RYD_WS_AllClasses),_crew];
												RHQ_Inf set [(count RHQ_Inf),_crew];
												RHQ_Crew set [(count RHQ_Crew),_crew];
												}
											}
										}
									foreach _vehs;
									
									RHQ_Inf = RHQ_Inf - ["b_uav_ai","i_uav_ai","o_uav_ai"];
									RHQ_Crew = RHQ_Crew - ["b_uav_ai","i_uav_ai","o_uav_ai"];
									
									//diag_log format ["[_rSide,_path4,_isArty,_name]: %1 typ: %2",[_rSide,_path4,_isArty,_name],_gpType];
									
									if not (_gpType in ["air","ship","ugv_01_base_f"]) then
										{
										_fac = _myFac;
										if ((toLower _fac) in ["guerilla"]) then {_fac = "blu_g_f"};
										//diag_log format ["chosen: %1,this: %2",[(RYD_WS_FacA select 2),(RYD_WS_FacB select 2)],(toLower _fac)];
										if not ((toLower _fac) in [(RYD_WS_FacA select 2),(RYD_WS_FacB select 2)]) exitWith {};
										
										_gp = [_rSide,_path4,_isArty,_name];
										
										//diag_log format ["gp: %1",_gp];
											
										switch (true) do
											{
											case (_gpType in ["tank"]) : 
												{
												_added = false;
												
													{
													if ((_x select 1) in [_path4]) exitWith {_added = true}
													}
												foreach (RYD_WS_B_Armored_G + RYD_WS_I_Armored_G + RYD_WS_O_Armored_G);
												
												if not (_added) then
													{
													switch (_rSide) do
														{
														case (west) : {RYD_WS_B_Armored_G set [(count RYD_WS_B_Armored_G),_gp]};
														case (resistance) : {RYD_WS_I_Armored_G set [(count RYD_WS_I_Armored_G),_gp]};
														case (east) : {RYD_WS_O_Armored_G set [(count RYD_WS_O_Armored_G),_gp]};
														}
													}
												};
												
											case (_gpType in ["wheeled_apc_f"]) : 
												{
												_added = false;
												
													{
													if ((_x select 1) in [_path4]) exitWith {_added = true}
													}
												foreach (RYD_WS_B_Mechanized_G + RYD_WS_I_Mechanized_G + RYD_WS_O_Mechanized_G);
												
												if not (_added) then
													{
													switch (_rSide) do
														{
														case (west) : {RYD_WS_B_Mechanized_G set [(count RYD_WS_B_Mechanized_G),_gp]};
														case (resistance) : {RYD_WS_I_Mechanized_G set [(count RYD_WS_I_Mechanized_G),_gp]};
														case (east) : {RYD_WS_O_Mechanized_G set [(count RYD_WS_O_Mechanized_G),_gp]};
														}
													}
												};
												
											case (_gpType in ["car"]) : 
												{
												_added = false;
												
													{
													if ((_x select 1) in [_path4]) exitWith {_added = true}
													}
												foreach (RYD_WS_B_Motorized_G + RYD_WS_I_Motorized_G + RYD_WS_O_Motorized_G);
												
												if not (_added) then
													{
													switch (_rSide) do
														{
														case (west) : {RYD_WS_B_Motorized_G set [(count RYD_WS_B_Motorized_G),_gp]};
														case (resistance) : {RYD_WS_I_Motorized_G set [(count RYD_WS_I_Motorized_G),_gp]};
														case (east) : {RYD_WS_O_Motorized_G set [(count RYD_WS_O_Motorized_G),_gp]};
														}
													}
												};
												
											default
												{
												_added = false;
												
													{
													if ((_x select 1) in [_path4]) exitWith {_added = true}
													}
												foreach (RYD_WS_B_Infantry_G + RYD_WS_I_Infantry_G + RYD_WS_O_Infantry_G);
												
												if not (_added) then
													{
													switch (_rSide) do
														{
														case (west) : {RYD_WS_B_Infantry_G set [(count RYD_WS_B_Infantry_G),_gp]};
														case (resistance) : {RYD_WS_I_Infantry_G set [(count RYD_WS_I_Infantry_G),_gp]};
														case (east) : {RYD_WS_O_Infantry_G set [(count RYD_WS_O_Infantry_G),_gp]};
														}
													}										
												}
											}										
										}
									}
								}
							}
						}
					}
				}
			}
		};
				
	for "_i" from 0 to ((count _vehClass) - 1) do
		{
		_class = _vehClass select _i;
		
		if (isClass _class) then
			{
			_class = toLower (configName _class);

			if not (_class isKindOf "ugv_01_base_f") then
				{
				if not (_class in (RYD_WS_Art_class + RYD_WS_Static_class + RYD_WS_Support_class + RYD_WS_NCCargo_class)) then
					{
					_scope = getNumber (_vehClass >> _class >> "Scope");
					if (_scope == 2) then
						{
						_vehClass2 = _vehClass >> _class;
						_side = getNumber (_vehClass2 >> "side");
						_hasD = (getNumber (_vehClass2 >> "hasDriver")) > 0;
						_isCargo = (getNumber (_vehClass2 >> "transportSoldier")) > 1;
						_sim = toLower (getText (_vehClass2 >> "simulation"));
						
						_turrets = _vehClass2 >> "Turrets";
						_mainT = _turrets >> "MainTurret";
						_isMainT = isClass _mainT;
						_crew = toLower (getText (_vehClass2 >> "crew"));
						_isAI = not ((_crew find "uav_ai") isEqualTo -1);
						
						if ((_side in [0,1,2]) and {not (_isAI)}) then
							{
							_fac = toLower (getText (_vehClass2 >> "faction"));
							
							if not (_hasD) then
								{													
								if (_isMainT) then
									{
									RHQ_Static set [(count RHQ_Static),_class];
									
									if (_fac in [(RYD_WS_FacA select 2),(RYD_WS_FacB select 2)]) then
										{
										switch (_side) do
											{
											case (0) : {RYD_WS_O_Static_G2 set [(count RYD_WS_O_Static_G2),_class]};
											case (1) : {RYD_WS_B_Static_G2 set [(count RYD_WS_B_Static_G2),_class]};
											case (2) : {RYD_WS_I_Static_G2 set [(count RYD_WS_I_Static_G2),_class]};
											}
										};
									
									_mags = getArray (_mainT >> "magazines");
									
										{
										_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
										_ammoC = configfile >> "CfgAmmo" >> _ammo;
										
										_isAA = (getNumber (_ammoC >> "airLock")) > 1;
										_isAT = ((((getNumber (_ammoC >> "irLock")) + (getNumber (_ammoC >> "laserLock"))) > 0) and ((getNumber (_ammoC >> "airLock")) < 2));
										
										if (_isAA) then {RHQ_StaticAA set [(count RHQ_StaticAA),_class]};
										if (_isAT) then {RHQ_StaticAT set [(count RHQ_StaticAT),_class]};
											
										if ((_isAA) or (_isAT)) exitWith {}
										}
									foreach _mags;
									
									if ((getNumber (_vehClass2 >> "artilleryScanner")) > 0) then
										{
										RHQ_Art set [(count RHQ_Art),_class];
										
										_prim = "";
										_rare = "";
										_sec = "";
										_smoke = "";
										_illum = "";

										if (_isMainT) then
											{
											_mags = getArray (_mainT >> "magazines");
											_maxHit = 10;
											
												{
												_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
												_ammoC = configfile >> "CfgAmmo" >> _ammo;
												
												_actHit = getNumber (_ammoC >> "hit");
												
												if (_actHit > _maxHit) then
													{
													_maxHit = _actHit;
													_prim = _x
													}
												}
											foreach _mags;
											
											_mags = _mags - [_prim];
											_mags0 = +_mags;
											_illumChosen = false;
											_smokeChosen = false;
											_rareChosen = false;
											_secChosen = false;
											
												{
												_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
												_ammoC = configfile >> "CfgAmmo" >> _ammo;
												
												_hit = getNumber (_ammoC >> "hit");
												_lc = _ammoC >> "lightColor";
												_sim = toLower (getText (_ammoC >> "simulation"));
												_subM = toLower (getText (_ammoC >> "submunitionAmmo"));
												
												if (_hit <= 10) then
													{
													if not (_subM in [""]) then
														{
														_ammoC = configfile >> "CfgAmmo" >> _subM;
														_hit = getNumber (_ammoC >> "hit")
														}
													};

												switch (true) do
													{
													case ((isArray _lc) and not (_illumChosen)) : 
														{
														_illum = _x;
														_mags = _mags - [_x];
														_illumChosen = true
														};
														
													case ((_hit <= 10) and (_subM in ["smokeshellarty"]) and not (_smokeChosen)) : 
														{
														_smoke = _x;
														_mags = _mags - [_x];
														_smokeChosen = true
														};
														
													case ((_sim in ["shotsubmunitions"]) and not (_rareChosen)) : 
														{
														_rare = _x;
														_mags = _mags - [_x];
														_rareChosen = true
														};
														
													case ((_hit > 10) and not ((_secChosen) or (_rare == _x)))  : 
														{
														_sec = _x;
														_mags = _mags - [_x];
														_secChosen = true
														}
													}
												}
											foreach _mags0;
											
											if (_sec in [""]) then
												{
												_maxHit = 10;
												
													{
													_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
													_ammoC = configfile >> "CfgAmmo" >> _ammo;
													_subAmmo = _ammoC >> "subMunitionAmmo";
													
													if ((isText _subAmmo) and {not ((getText _subAmmo) in [""])}) then
														{
														_ammoC = configfile >> "CfgAmmo" >> (getText _subAmmo);
														};
														
													_actHit = getNumber (_ammoC >> "hit");
													
													if (_actHit > _maxHit) then
														{
														_maxHit = _actHit;
														_sec = _x
														}
													}
												foreach _mags;
												}
											};
											
										_arr = [_prim,_rare,_sec,_smoke,_illum];
										if (({_x in [""]} count _arr) < 5) then
											{
											RydHQ_Add_OtherArty set [(count RydHQ_Add_OtherArty),[[_class],_arr]]
											}
										}
									}
								}
							else
								{
								_isMan = isNumber (_vehClass2 >> "isMan");
								
								if (_isMan) then
									{
									_isMan = (getNumber (_vehClass2 >> "isMan")) > 0;
									};
								
								if not (_isMan) then
									{
									_isAmmoS = (getNumber (_vehClass2 >> "transportAmmo")) > 0;
									_isFuelS = (getNumber (_vehClass2 >> "transportFuel")) > 0;
									_isRepS = (getNumber (_vehClass2 >> "transportRepair")) > 0;
									_isMedS = (getNumber (_vehClass2 >> "attendant")) > 0;
									
									if (_isAmmoS) then 
										{
										RHQ_Ammo set [(count RHQ_Ammo),_class];
										if not (_class in RHQ_Support) then
											{
											RHQ_Support set [(count RHQ_Support),_class]
											}
										};
										
									if (_isFuelS) then 
										{
										RHQ_Fuel set [(count RHQ_Fuel),_class];
										if not (_class in RHQ_Support) then
											{
											RHQ_Support set [(count RHQ_Support),_class]
											}
										};
										
									if (_isRepS) then 
										{
										RHQ_Rep set [(count RHQ_Rep),_class];
										if not (_class in RHQ_Support) then
											{
											RHQ_Support set [(count RHQ_Support),_class]
											}
										};
										
									if (_isMedS) then 
										{
										RHQ_Med set [(count RHQ_Med),_class];
										if not (_class in RHQ_Support) then
											{
											RHQ_Support set [(count RHQ_Support),_class]
											}
										};
										
									if (_class in RHQ_Support) then
										{
										_side = getNumber (_vehClass2 >> "side");

										if (_fac in [(RYD_WS_FacA select 2),(RYD_WS_FacB select 2)]) then
											{
											switch (_side) do
												{
												case (0) : {RYD_WS_O_Support_G2 set [(count RYD_WS_O_Support_G2),_class]};
												case (1) : {RYD_WS_B_Support_G2 set [(count RYD_WS_B_Support_G2),_class]};
												case (2) : {RYD_WS_I_Support_G2 set [(count RYD_WS_I_Support_G2),_class]};
												}
											};
										};
										
									if not (_class in (RYD_WS_Air_class + RHQ_Air)) then	
										{
										_base = _class;
										
										while {not (_base in ["air"])} do
											{
											_base = inheritsFrom (_vehClass >> _base);
											if not (isClass _base) exitWith {};
											_base = toLower (configName _base);
											if (_base in ["allvehicles","all"]) exitWith {};
											};
										
										if (_base in ["air"]) then 
											{
											_isChopper = _sim in ["helicopterx","helicopterrtd"];
											
											_isUAV = if (isNumber (_vehClass2 >> "Uav")) then
												{
												((getNumber (_vehClass2 >> "Uav")) > 0)
												}
											else
												{
												false
												};

											if (_isChopper) then
												{
												_mainT = _turrets >> "MainTurret";
												_isMainT = isClass _mainT;
												
												if ((getNumber (_vehClass2 >> "transportSoldier")) > 1) then 
													{
													RHQ_Cargo set [(count RHQ_Cargo),_class];
													if ((((count _turrets) + (count ((getArray (_vehClass2 >> "Weapons")) - ["CMFlareLauncher"]))) < 1)) then
														{
														RHQ_NCCargo set [(count RHQ_NCCargo),_class];
														}
													};
												
												RHQ_Air set [(count RHQ_Air),_class];

												if (_fac in [(RYD_WS_FacA select 2),(RYD_WS_FacB select 2)]) then
													{
													switch (_side) do
														{
														case (0) : {RYD_WS_O_Air_G2 set [(count RYD_WS_O_Air_G2),_class]};
														case (1) : {RYD_WS_B_Air_G2 set [(count RYD_WS_B_Air_G2),_class]};
														case (2) : {RYD_WS_I_Air_G2 set [(count RYD_WS_I_Air_G2),_class]};
														}
													};
												
												if ((((count _turrets) + (count ((getArray (_vehClass2 >> "Weapons")) - ["CMFlareLauncher"]))) < 1)) then
													{
													RHQ_NCAir set [(count RHQ_NCAir),_class];
													}
												};
																								
											if (_isUAV) then
												{
												RHQ_Air set [(count RHQ_Air),_class];
												RHQ_RAir set [(count RHQ_RAir),_class]
												}
											}
										};
										
									if not (_class in (RYD_WS_NCCargo_class + RHQ_NCCargo)) then
										{
										if not (_isMainT) then
											{
											if (_isCargo) then
												{
												if (_sim in ["carx","helicopterx","helicopterrtd"]) then
													{
													if (_fac in [(RYD_WS_FacA select 2),(RYD_WS_FacB select 2)]) then
														{
														if (({_x} count [_isAmmoS,_isFuelS,_isRepS,_isMedS]) < 1) then
															{
															switch (_side) do
																{
																case (0) : {RYD_WS_O_NCCargo_G2 set [(count RYD_WS_O_NCCargo_G2),_class]};
																case (1) : {RYD_WS_B_NCCargo_G2 set [(count RYD_WS_B_NCCargo_G2),_class]};
																case (2) : {RYD_WS_I_NCCargo_G2 set [(count RYD_WS_I_NCCargo_G2),_class]};
																}
															}
														}
													}
												}
											}
										}	
									}
								else
									{
									_desc = toLower (getText (_vehClass2 >> "textSingular"));
									
									if (_desc in ["officer"]) then
										{
										if (_fac in [(RYD_WS_FacA select 2),(RYD_WS_FacB select 2)]) then
											{
											switch (_side) do
												{
												case (0) : {RYD_WS_O_Officers_G2 set [(count RYD_WS_O_Officers_G2),_class]};
												case (1) : {RYD_WS_B_Officers_G2 set [(count RYD_WS_B_Officers_G2),_class]};
												case (2) : {RYD_WS_I_Officers_G2 set [(count RYD_WS_I_Officers_G2),_class]};
												}
											}
										};									
									}
								}
							}
						}
					}
				}
			}
		}
	};
	
RYD_WS_isOnMap = 
	{
	private ["_pos","_onMap"];
	
	_pos = _this select 0;
	
	if (isNil "_pos") exitWith {false};
	if not (typeName _pos in [(typeName [])]) exitWith {false};
	
	_pos = +_pos;
	_pos reSize 2;

	if (({not (isNil {_x})} count _pos) < 2) exitWith {false};
	if (({(typeName _x) in [(typeName 0)]} count _pos) < 2) exitWith {false};
		
	_onMap = switch (true) do
		{
		case (({_x < 0} count _pos) > 0) : {false};
		case (({_x > RydBB_MapXMax} count _pos) > 0) : {false};
		default {true}
		};
		
	_onMap
	};

RYD_WS_MapAnalyze = 
	{
	private ["_cntr","_mapSize","_lng","_nmbr","_nbr","_secpos","_sPosX","_sPosY","_sUrban","_sForest","_sHills","_sFlat","_sSea","_samplePos","_topArr","_sRoads","_nbr","_sum","_mark","_sectors","_strArea",
	"_objRad","_loc10","_loc5","_loc2","_loc1","_locHill","_frstV","_k","_j","_fAr","_fPnt","_fVal","_fTkn","_fX","_fY","_sAr","_sPnt","_sVal","_sTkn","_sX","_sY"];
	
	_cntr = getArray (configFile >> "CfgWorlds" >> worldName >> "centerPosition");

	if not (isNil "RydBB_MC") then
		{
		if ((typeName RydBB_MC) == "OBJECT") then {_cntr = getPosATL RydBB_MC} else {_cntr = RydBB_MC};
		RydBB_MapC = _cntr;
		}
	else
		{
		_mapSize = getNumber (configFile >> "CfgWorlds" >> worldName >> "mapSize");
		
		RydBB_MapXMax = _mapSize;
		RydBB_MapYMax = RydBB_MapXMax;
		RydBB_MapC = [_mapSize/2,_mapSize/2];

		_cntr = RydBB_MapC
		};

	//if ((_cntr select 0) < 1000) then {_cntr = getArray (configFile >> "CfgWorlds" >> worldName >> "centerPosition")};

	//_mark = "center" + str (random 1000);
	//_mark = [_mark,_cntr,"ColorBlue","ICON",[1.5,1.5],0,1,"DOT",(str _cntr)] call RYD_Marker;

	_lng = (_cntr select 0)*2;
	if not (isNil "RydBB_MC") then
		{
		if ((typeName RydBB_MC) == "OBJECT") then
			{
			_lng = ((triggerArea RydBB_MC) select 0)*2
			}
		else
			{
			_lng = RydBB_MapLng
			};

		RydBB_MapXMax = (RydBB_MapC select 0) + _lng/2;
		RydBB_MapYMax = (RydBB_MapC select 1) + _lng/2;
		RydBB_MapXMin = (RydBB_MapC select 0) - _lng/2;
		RydBB_MapYMin = (RydBB_MapC select 1) - _lng/2;
		};

	_nmbr = round (_lng/500);

	missionNameSpace setVariable ["BattleF",[_cntr,_lng,_nmbr]];

	RydBB_Sectors = ([_cntr,_lng,0,_nmbr] call RYD_Sectorize) select 0;
	
	/*_markers = [];

		{
		diag_log format ["Sector: %1",_x];
		_mark = "sector" + str (random 1000);
		_mark = [_mark,position _x,"ColorBlue","RECTANGLE",size _x,direction _x,1,"Border",""] call RYD_Marker;
		_markers set [(count _markers),_mark];
		_x setVariable ["Over_Mark",_mark];
		}
	foreach RydBB_Sectors;*/


	_nbr = 0;

	if (RydBB_Debug) then {diag_log "Big Boss studies the map."};

		{
		_x setVariable ["BBSec",true];		

		_secpos = position _x;
		_sPosX = _secpos select 0;
		_sPosY = _secpos select 1;

		_sUrban = 0;
		_sForest = 0;
		_sHills = 0;
		_sFlat = 0;
		_sSea = 0;
		_sGr = 0;
		_count = 10;

		for "_i" from 1 to _count do
			{
			_samplePos = [_sPosX + ((random 500) - 250),_sPosY + ((random 500) - 250)];

			_topArr = [_samplePos,1] call RYD_TerraCognita;

			_sUrban = _sUrban + (_topArr select 0);
			_sForest = _sForest + (_topArr select 1);
			_sHills = _sHills + (_topArr select 2);
			_sFlat = _sFlat + (_topArr select 3);
			_sSea = _sSea + (_topArr select 4);
			_sGr = _sGr + (_topArr select 5);
			};

		_sUrban = round (_sUrban*100/_count);
		_sForest =  round (_sForest*100/_count);
		_sHills =  round(_sHills*100/_count);
		_sFlat =  round (_sFlat*100/_count);
		_sSea = round (_sSea*100/_count);
		_sGr = round (_sGr*10/_count);

		_x setVariable ["Topo_Urban",_sUrban];
		_x setVariable ["Topo_Forest",_sForest];
		_x setVariable ["Topo_Hills",_sHills];
		_x setVariable ["Topo_Flat",_sFlat];
		_x setVariable ["Topo_Sea",_sSea];
		_x setVariable ["Topo_Grd",_sGr];
		
		_sum = _sUrban + _sForest + _sHills + _sFlat + _sSea;
		
		_sUrban = round (_sUrban*100/_sum);
		_sForest =  round (_sForest*100/_sum);
		_sHills =  round(_sHills*100/_sum);
		_sFlat =  round (_sFlat*100/_sum);
		_sSea = round (_sSea*100/_sum);
		_sGr = round (_sGr*100/_sum);
		
		_x setVariable ["Topo_UrbanP",_sUrban];
		_x setVariable ["Topo_ForestP",_sForest];
		_x setVariable ["Topo_HillsP",_sHills];
		_x setVariable ["Topo_FlatP",_sFlat];
		_x setVariable ["Topo_SeaP",_sSea];
		_x setVariable ["Topo_GrdP",_sGr];	

		_sRoads = count (_secpos nearRoads 250);

		_x setVariable ["Topo_roads",_sRoads];

		_mark = _x getVariable "Over_Mark";

		_nbr = _nbr + 1;
		_sum = count RydBB_Sectors;

		if not (isMultiplayer) then
			{
			progressLoadingScreen (_nbr/(2 * _sum))
			}
		}
	foreach RydBB_Sectors;

	RydBB_mapReady = true;

	_sectors = RydBB_Sectors;

	_strArea = [];

	if (RydBB_Debug) then
		{
		//RydBBa_SAL globalChat format ["Big Boss %1 is looking for strategic objectives.",_BBSide];
		diag_log "Big Boss is looking for strategic objectives."
		};

	_objRad = 25000;

	_cntr = (missionNameSpace getVariable "BattleF") select 0;
	_lng = (missionNameSpace getVariable "BattleF") select 1;

	if not (isNil "RydBB_MC") then
		{
		_objRad = _lng/2
		};

	_loc10 = nearestLocations [_cntr, ["NameCityCapital"], _objRad]; 
	_loc5 = nearestLocations [_cntr, ["NameCity","Airport"], _objRad]; 
	_loc2 = nearestLocations [_cntr, ["NameVillage"], _objRad]; 
	
		{
		if ((tolower (text _x)) in ["sagonisi"]) exitWith
			{
			_loc2 set [_foreachIndex, "deleteThis"]
			}
		}
	foreach _loc2;
	
	_loc2 = _loc2 - ["deleteThis"];
	
	_loc1 = nearestLocations [_cntr, ["BorderCrossing"], _objRad]; 
	_locHill = nearestLocations [_cntr, ["Hill","ViewPoint"], _objRad]; 

		{
		_strArea set [(count _strArea),[(position _x),10,false]]
		}
	foreach _loc10;

		{
		_strArea set [(count _strArea),[(position _x),5,false]]
		}
	foreach _loc5;

		{
		_strArea set [(count _strArea),[(position _x),2,false]]
		}
	foreach _loc2;

		{
		_strArea set [(count _strArea),[(position _x),1,false]]
		}
	foreach _loc1;


		{
		_topArr = [(position _x),3] call RYD_TerraCognita;
		_frstV = _topArr select 1;
		if (_frstV > 0.25) then 
			{
			_strArea set [(count _strArea),[(position _x),1,false]]
			}
		else
			{
			_strArea set [(count _strArea),[(position _x),2,false]]
			}
		}
	foreach _locHill;

	//_strArea = [];
	
	if ((count _strArea) < 20) then
		{
		_sectorsL = [];
		
			{
			_sea = _x getVariable ["Topo_Sea",0];
			if (_sea < 1) then
				{
				_sectorsL pushBack _x;
				_x setVariable ["RYD_myLocIx",(_foreachIndex + 1)];
				}
			}
		foreach _sectors;
		_sectors2 = [_sectorsL] call RYD_RandomOrdB;
		_tresh = 100;
		_wantedAm = ((round ((count _sectors)/75)) max 5) min 100;
		while {((count _strArea) < _wantedAm)} do
			{
				{
				_pos = position _x;
				_nearS = [_pos,_sectorsL,0,750,8] call RYD_WS_FindSectorInRange;
				_urban = (_x getVariable ["Topo_Urban",0]) * 1.75;
				if ((_urban > _tresh) and {(({not ((_x getVariable ["Topo_Urban",0]) < _urban)} count _nearS) < 1)}) then
					{
					_strArea pushBack [_pos,1,false];
					_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
					_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
					_sectors2 set [_foreachIndex,0];
					//_mark = "sectorU" + (str _pos);
					//_mark = [_mark,_pos,"ColorGrey","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
					//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["U: %1",_urban])] call RYD_Marker;
					}
				else
					{
					_forest = (_x getVariable ["Topo_Forest",0])/1.5;
					if ((_forest > _tresh) and {(({not ((_x getVariable ["Topo_Forest",0]) < _forest)} count _nearS) < 1)}) then 
						{
						_strArea pushBack [_pos,1,false];
						_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
						_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
						_sectors2 set [_foreachIndex,0];
						//_mark = "sectorF" + (str _pos);
						//_mark = [_mark,_pos,"ColorGreen","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
						//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["F: %1",_forest])] call RYD_Marker;
						}
					else
						{
						_hills = (_x getVariable ["Topo_Hills",0])/1.1;
						if ((_hills > _tresh) and {(({not ((_x getVariable ["Topo_Hills",0]) < _hills)} count _nearS) < 1)}) then 
							{
							_strArea pushBack [_pos,1,false];
							_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
							_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
							_sectors2 set [_foreachIndex,0];
							//_mark = "sectorH" + (str _pos);
							//_mark = [_mark,_pos,"ColorKhaki","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
							//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["H: %1",_hills])] call RYD_Marker;
							}
						else
							{
							_grd = (_x getVariable ["Topo_Grd",0])/5;
							if ((_grd > _tresh) and {(({not ((_x getVariable ["Topo_Grd",0]) < _grd)} count _nearS) < 1)}) then 
								{
								_strArea pushBack [_pos,1,false];
								_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
								_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
								_sectors2 set [_foreachIndex,0];
								//_mark = "sectorG" + (str _pos);
								//_mark = [_mark,_pos,"ColorRed","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
								//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["G: %1",_grd])] call RYD_Marker;
								}
							}
						}
					}
				}
			foreach _sectors2;
			
			_tresh = _tresh - 20;
			if (_tresh < 0) exitWith {};
			_sectors2 = _sectors2 - [0];
			};
		};
	
	if ((count _strArea) < 1) then
		{
		_sectorsL = [];
		
			{
			_sea = _x getVariable ["Topo_Sea",0];
			if (_sea < 100) then
				{
				_sectorsL pushBack _x;
				_x setVariable ["RYD_myLocIx",(_foreachIndex + 1)];
				}
			}
		foreach _sectors;
		_sectors2 = [_sectorsL] call RYD_RandomOrdB;
		
			{
			_pos = position _x;
			_nearS = [_pos,_sectorsL,0,750,8] call RYD_WS_FindSectorInRange;
			_urban = (_x getVariable ["Topo_Urban",0]) * 1.75;
			if (({not ((_x getVariable ["Topo_Urban",0]) < _urban)} count _nearS) < 1) then
				{
				_strArea pushBack [_pos,1,false];
				_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
				_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
				//_mark = "sectorU" + (str _pos);
				//_mark = [_mark,_pos,"ColorGrey","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
				//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["U: %1",_urban])] call RYD_Marker;
				}
			else
				{
				_forest = (_x getVariable ["Topo_Forest",0])/1.5;
				if (({not ((_x getVariable ["Topo_Forest",0]) < _forest)} count _nearS) < 1) then 
					{
					_strArea pushBack [_pos,1,false];
					_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
					_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
					//_mark = "sectorF" + (str _pos);
					//_mark = [_mark,_pos,"ColorGreen","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
					//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["F: %1",_forest])] call RYD_Marker;
					}
				else
					{
					_hills = (_x getVariable ["Topo_Hills",0])/1.1;
					if (({not ((_x getVariable ["Topo_Hills",0]) < _hills)} count _nearS) < 1) then 
						{
						_strArea pushBack [_pos,1,false];
						_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
						_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
						//_mark = "sectorH" + (str _pos);
						//_mark = [_mark,_pos,"ColorKhaki","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
						//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["H: %1",_hills])] call RYD_Marker;
						}
					else
						{
						_grd = (_x getVariable ["Topo_Grd",0])/5;
						if (({not ((_x getVariable ["Topo_Grd",0]) < _grd)} count _nearS) < 1) then 
							{
							_strArea pushBack [_pos,1,false];
							_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
							_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
							//_mark = "sectorG" + (str _pos);
							//_mark = [_mark,_pos,"ColorRed","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
							//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["G: %1",_grd])] call RYD_Marker;
							}
						else
							{
							if (({((_x getVariable ["Topo_Sea",0]) <= _sea)} count _nearS) < 1) then 
								{
								_strArea pushBack [_pos,1,false];
								_loc = createLocation ["NameLocal", _pos, ((size _x) select 0),((size _x) select 1)];
								_loc setText (format ["Area %1",(_x getVariable ["RYD_myLocIx",(_foreachIndex + 1)])]);
								//_mark = "sectorL" + (str _pos);
								//_mark = [_mark,_pos,"ColorWhite","RECTANGLE",size _x,direction _x,1,"SolidBorder",""] call RYD_Marker;
								//_mark = [(_mark + "I"),_pos,"ColorBlack","ICON",[1,1],direction _x,1,"mil_dot",(format ["L: %1",_sea])] call RYD_Marker;
								}
							}
						}
					}
				}
			}
		foreach _sectors2;
		};
	
	_strArea0 = +_strArea;

		{
		_fAr = _x;
		_k = _foreachIndex;
		_fPnt = _fAr select 0;
		_fVal = _fAr select 1;
		_fTkn = _fAr select 2;

		_fX = _fPnt select 0;
		_fY = _fPnt select 1;

			{
			_sAr = _x;
			_j = _foreachIndex;
			_sPnt = _sAr select 0;
			_sVal = _sAr select 1;
			_sTkn = _sAr select 2;

			_sX = _sPnt select 0;
			_sY = _sPnt select 1;

			if ((_fPnt distance _sPnt) < 400) then
				{
				if not ((_fPnt select 0) == (_sPnt select 0)) then 
					{
					if (_fVal > _sVal) then
						{
						_strArea set [_k,[[(_fX + _sX)/2,(_fY + _sY)/2,0],_fVal + _sVal,_fTkn]];
						_strArea set [_j,"deleteThis"]
						}
					else
						{
						_strArea set [_j,[[(_fX + _sX)/2,(_fY + _sY)/2,0],_fVal + _sVal,_sTkn]];
						_strArea set [_k,"deleteThis"]
						}
					}
				}
			}
		foreach _strArea0
		}
	foreach _strArea0;

	_strArea = _strArea - ["deleteThis"];
	
	_strArea0 = nil;

	missionNameSpace setVariable ["A_SAreas",_strArea];
	missionNameSpace setVariable ["B_SAreas",_strArea];
	
	true
	};
	
RYD_WS_Battlefield = 
	{
	_mode = _this select 0;
	_taken = _this select 1;

	_strAr = if ((count RYD_WS_BattlePosition) < 2) then
		{
		+(missionNameSpace getVariable ["A_SAreas",[]])
		}
	else
		{
		[[RYD_WS_BattlePosition,1,false]]
		};

	_posArray = [];
	
	switch (true) do
		{
		case (_mode in [0,1]) :
			{
			_defPos = [];
			_attPos = [];
			
			_ct = 0;
			_nearSea = 0;
			
			_excluded = +(_taken select _mode);
			_taken set [_mode,-1];
			_taken = _taken - [-1];
			_taken = +(_taken select 0);
			
			_strAr0 = [];
			
				{
				_pos = _x select 0;
				
				if (({((_pos distance _x) < 350)} count _taken) > 0) then
					{
					_strAr0 set [(count _strAr0),_x]
					}
				}
			foreach _strAr;
			
			if (((count _strAr0) > 0) and ((random 100) < 30)) then
				{
				_strAr = _strAr0
				}
			else
				{				
					{
					_pos = _x select 0;
					
					if (({((_pos distance _x) < 400)} count _excluded) > 0) then
						{
						_strAr set [_foreachIndex,0]
						}
					}
				foreach _strAr;
				
				_strAr = _strAr - [0]
				};
			
			if ((count _strAr) < 1) then
				{
				_strAr = if ((count RYD_WS_BattlePosition) < 2) then
					{
					+(missionNameSpace getVariable ["A_SAreas",[]])
					}
				else
					{
					[[RYD_WS_BattlePosition,1,false]]
					};
				};
			
			while {(((count _attPos) < 2) or not ([_attPos] call RYD_WS_isOnMap) or {_nearSea > 10})} do
				{
				_defPos = (_strAr select (floor (random (count _strAr)))) select 0;
				
				_attPos = [_defPos,_strAr,1500,3000] call RYD_WS_FindPosInRange;
				_nearSeaD = [_defPos,600] call RYD_WS_NearSea;
				_nearSeaA = [_attPos,600] call RYD_WS_NearSea;
				_nearSea = _nearSeaD max _nearSeaA;
				_ct = _ct + 1;
				if (_ct > 20) exitWith {_attPos = [_defPos,10,100] call RYD_RandomAroundMM}
				};
			
			_posArray = switch (_mode) do
				{	
				case (0) : {[_defPos,_attPos,_defPos]};
				case (1) : {[_attPos,_defPos,_defPos]}
				}
			};
			
		case (_mode in [2]) :
			{
			_center = (_strAr select (floor (random (count _strAr)))) select 0;
				
			_posA = [_center,800,1600,50] call RYD_WS_FindLandPos;
			_nearSea = [_posA,600] call RYD_WS_NearSea;
			
			_ct = 0;
			
			while {((surfaceIsWater _posA) or not ([_posA] call RYD_WS_isOnMap) or {_nearSea > 10})} do
				{
				_center = (_strAr select (floor (random (count _strAr)))) select 0;
				
				_posA = [_center,1200,2400,50] call RYD_WS_FindLandPos;
				_nearSea = [_posA,600] call RYD_WS_NearSea;
				_ct = _ct + 1;
				if (_ct > 10) exitWith {_posA = [_center,100,300] call RYD_RandomAroundMM}
				};
				
			_battlePoint = +_center;
			
			_angleA = [_center,_posA,0] call RYD_AngTowards;
			
			_center = [_battlePoint,_angleA + 210 - (random 60),1800] call RYD_PosTowards2D;
			
			_posB = [_center,0,400,50] call RYD_WS_FindLandPos;
			_nearSea = [_posB,600] call RYD_WS_NearSea;
			
			_ct = 0;
			
			while {((surfaceIsWater _posB) or (_nearSea > 10))} do
				{
				_center = [_battlePoint,_angleA + 210 - (random 60),1800 + (((2 * _ct) - 10) * 50)] call RYD_PosTowards2D;
				
				_posB = [_center,0,400,50] call RYD_WS_FindLandPos;
				_nearSea = [_posB,600] call RYD_WS_NearSea;
				_ct = _ct + 1;
				if (_ct > 10) exitWith {_posB = [_battlePoint,100,300] call RYD_RandomAroundMM}
				};
			
			_posArray = [_posA,_posB,_battlePoint]
			};
		};
		
		{
		_x set [2,0]
		}
	foreach _posArray;
	
	_posArray
	};
	
RYD_WS_Forces = 
	{
	_mode = _this select 0;
	_scale = _this select 1;
	_sides = _this select 2;
	_topoCoeff = sqrt (_this select 3);
	
	_infPoolA = [];
	_motPoolA = [];
	_mechPoolA = [];
	_armPoolA = [];
	
	_infPoolB = [];
	_motPoolB = [];
	_mechPoolB = [];
	_armPoolB = [];
	
	_infPool = [];
	_motPool = [];
	_mechPool = [];
	_armPool = [];	
		
	switch (_sides select 0) do
		{
		case (west) : 
			{
			_infPoolA = RYD_WS_B_Infantry_G;
			_motPoolA = RYD_WS_B_Motorized_G;
			_mechPoolA = RYD_WS_B_Mechanized_G;
			_armPoolA = RYD_WS_B_Armored_G
			};
			
		case (east) : 
			{
			_infPoolA = RYD_WS_O_Infantry_G;
			_motPoolA = RYD_WS_O_Motorized_G;
			_mechPoolA = RYD_WS_O_Mechanized_G;
			_armPoolA = RYD_WS_O_Armored_G
			};
			
		case (resistance) : 
			{
			_infPoolA = RYD_WS_I_Infantry_G;
			_motPoolA = RYD_WS_I_Motorized_G;
			_mechPoolA = RYD_WS_I_Mechanized_G;
			_armPoolA = RYD_WS_I_Armored_G
			};
		};
		
	switch (_sides select 1) do
		{
		case (west) : 
			{
			_infPoolB = RYD_WS_B_Infantry_G;
			_motPoolB = RYD_WS_B_Motorized_G;
			_mechPoolB = RYD_WS_B_Mechanized_G;
			_armPoolB = RYD_WS_B_Armored_G
			};
			
		case (east) : 
			{
			_infPoolB = RYD_WS_O_Infantry_G;
			_motPoolB = RYD_WS_O_Motorized_G;
			_mechPoolB = RYD_WS_O_Mechanized_G;
			_armPoolB = RYD_WS_O_Armored_G
			};
			
		case (resistance) : 
			{
			_infPoolB = RYD_WS_I_Infantry_G;
			_motPoolB = RYD_WS_I_Motorized_G;
			_mechPoolB = RYD_WS_I_Mechanized_G;
			_armPoolB = RYD_WS_I_Armored_G
			};
		};
	
	_forcesA_inf = [];
	_forcesA_mot = [];
	_forcesA_mech = [];
	_forcesA_arm = [];
	
	_forcesB_inf = [];
	_forcesB_mot = [];
	_forcesB_mech = [];
	_forcesB_arm = [];
	
	_forces = [[_forcesA_inf,_forcesA_mot,_forcesA_mech,_forcesA_arm],[_forcesB_inf,_forcesB_mot,_forcesB_mech,_forcesB_arm]];
		
	_arr = 0;
	_gps = [];
	
	_amountA = (11 + (floor (random 3))) * _scale;
	_amountB = (11 + (floor (random 3))) * _scale;
	
	_sumAm = _amountA + _amountB;
	
	_amountB = round ((_sumAm/(1 + RYD_WS_Ratio)) * (sqrt RYD_WS_AdvantageB));
	_amountA = round ((_amountB * RYD_WS_Ratio) * (sqrt RYD_WS_AdvantageA));
	
	//diag_log format ["A: %1 B: %2",_amountA,_amountB];
	
		{
		_artyC = 0;
		
		_ratio = switch (_foreachIndex) do
			{
			case (0) : {RYD_WS_Ratio};
			case (1) : {1/RYD_WS_Ratio};
			};
			
		_HSratio = switch (_foreachIndex) do
			{
			case (0) : {RYD_WS_HSRatio_A};
			case (1) : {RYD_WS_HSRatio_B};
			};
		
		_inf = switch (_foreachIndex) do
			{
			case (0) : {_forcesA_inf};
			case (1) : {_forcesB_inf};
			};
			
		_mot = switch (_foreachIndex) do
			{
			case (0) : {_forcesA_mot};
			case (1) : {_forcesB_mot};
			};
			
		_mech = switch (_foreachIndex) do
			{
			case (0) : {_forcesA_mech};
			case (1) : {_forcesB_mech};
			};
			
		_arm = switch (_foreachIndex) do
			{
			case (0) : {_forcesA_arm};
			case (1) : {_forcesB_arm};
			};
			
		switch (_foreachIndex) do
			{
			case (0) :
				{
				_infPool = _infPoolA;
				_motPool = _motPoolA;
				_mechPool = _mechPoolA;
				_armPool = _armPoolA
				};
				
			case (1) :
				{
				_infPool = _infPoolB;
				_motPool = _motPoolB;
				_mechPool = _mechPoolB;
				_armPool = _armPoolB				
				};
			};

		_amount = switch (_foreachIndex) do
			{
			case (0) : {_amountA};
			case (1) : {_amountB};
			};
			
		_mpl = 1;
		
		if (_mode == _foreachIndex) then
			{
			if ((random 100) < 90) then
				{
				_mpl = 0.75
				};
				
			if ((random 100) < 85) then
				{
				if (((_foreachIndex == 0) and ((_amount * 1.5) > _amountB)) or ((_foreachIndex == 1) and ((_amount * 1.5) > _amountA))) then
					{
					_amount = ceil ((_amount/(1 + (random 0.75) + (random 0.75))));
					}
				}
			};
			
		//diag_log format ["am: %1 sc: %2",_amount,_scale];
		
		_notEmpty = [];
		_fcs = [_inf,_mot,_mech,_arm];
		
			{
			if ((count _x) > 0) then
				{
				_notEmpty set [(count _notEmpty),[_x,_fcs select _foreachIndex]]
				}
			}
		foreach [_infPool,_motPool,_mechPool,_armPool];
		
		if ((count _notEmpty) > 0) then
			{	
			for "_ixA" from 1 to _amount do
				{
				_rnd = (random 100) * _mpl;
				
				_infC = (50 * (((_topoCoeff * _HSratio) min 1.9) max 0.1));
				_motC = (80 * ((((_topoCoeff max 0.4) * _HSratio) min 1.2)) max 0.1);
				_mechC = (80 * (((_topoCoeff * _HSratio) min 1.2)) max 0.3);
				
				//diag_log format ["tcoeff: %1 ratio: %2 infc: %3 motc: %4 mechc: %5 rnd: %6",_topoCoeff,_HSratio,_infC,_motC,_mechC,_rnd];
				
				switch (true) do
					{
					case (_rnd < _infC) :
						{
						_gps = _infPool;
						_arr = _inf;
						//diag_log format ["inf: %1",count _gps];
						if ((count _gps) < 1) then
							{
							_sec = _notEmpty select (floor (random (count _notEmpty)));
							_gps = _sec select 0;
							_arr = _sec select 1
							}
						};
						
					case (_rnd < _motC) :
						{
						_gps = _motPool;
						_arr = _mot;
						//diag_log format ["mot: %1",count _gps];
						if ((count _gps) < 1) then
							{
							_sec = _notEmpty select (floor (random (count _notEmpty)));
							_gps = _sec select 0;
							_arr = _sec select 1
							}
						};
						
					default
						{
						_rnd = (random 100) * _mpl;
						
						if (_rnd < _mechC) then
							{
							_gps = _mechPool;
							_arr = _mech;
							//diag_log format ["mech: %1",count _gps];
							if ((count _gps) < 1) then
								{
								_sec = _notEmpty select (floor (random (count _notEmpty)));
								_gps = _sec select 0;
								_arr = _sec select 1
								}							
							}
						else
							{
							_gps = +_armPool;
							_arr = _arm;
							
							if (0.5 < (random (1 + (_artyC^2)))) then
								{
									{
									if (_x select 2) then
										{
										_gps set [_foreachIndex,0]
										}
									}
								foreach _gps;
								
								_gps = _gps - [0]
								};
							//diag_log format ["tank: %1",count _gps];
							if ((count _gps) < 1) then
								{
								_sec = _notEmpty select (floor (random (count _notEmpty)));
								_gps = _sec select 0;
								_arr = _sec select 1
								}
							}
						}
					};
					
				_gp = _gps select (floor (random (count _gps)));

				if (_gp select 2) then
					{
					_artyC = _artyC + 1
					};
				
				_arr set [(count _arr),[_gp select 0,_gp select 1,_gp select 3,_gp select 2]]
				};
			}
		}
	foreach [0,1];

	_forces
	};
	
RYD_WS_FindLandPos = 
	{
	private ["_center","_minR","_maxR","_maxT","_final","_ct","_nearSea","_noWater"];
	
	_center = _this select 0;
	_minR = _this select 1;
	_maxR = _this select 2;
	_maxT = _this select 3;
	_noWater = 600;
	if ((count _this) > 4) then {_noWater = _this select 4};
	
	_final = [_center,_minR,_maxR] call RYD_RandomAroundMM;
	_nearSea = [_final,_noWater] call RYD_WS_NearSea;
	
	_ct = 0;
	
	while {((surfaceIsWater _final) or not ([_final] call RYD_WS_isOnMap) or {_nearSea > 10})} do
		{
		_final = [_center,_minR,_maxR] call RYD_RandomAroundMM;
		
		_maxR = _maxR + (_maxR/(2 * _maxT));
		
		_nearSea = [_final,_noWater] call RYD_WS_NearSea;
		_ct = _ct + 1;
		if (_ct > _maxT) exitWith {}
		};
		
	_final
	};
	
RYD_WS_FindPosInRange = 
	{
	private ["_center","_areas","_minR","_maxR","_final","_inRange","_pos","_dst","_nearSea"];
	
	_center = _this select 0;
	_areas = _this select 1;
	_minR = _this select 2;
	_maxR = _this select 3;
	
	_final = [0,0,0];
	_inRange = [];
	
	if ((random 100) > 30) then
		{
			{
			_pos = _x select 0;
			_dst = _center distance _pos;
			
			if (_dst < _maxR) then
				{
				if (_dst > _minR) then
					{
					_nearSea = [_pos,600] call RYD_WS_NearSea;
					
					if (_nearSea < 10) then
						{
						_inRange set [(count _inRange),_pos]
						}
					}
				}
			}
		foreach _areas
		};
	
	if ((count _inRange) > 0) then
		{
		_final = _inRange select (floor (random (count _inRange)));
		}
	else
		{
		_final = [_center,_minR,_maxR,100] call RYD_WS_FindLandPos
		};
	
	_final
	};
	
RYD_WS_FindSectorInRange = 
	{
	private ["_center","_areas","_minR","_maxR","_tresh","_inRange","_pos","_dst"];
	
	_center = _this select 0;
	_areas = _this select 1;
	_minR = _this select 2;
	_maxR = _this select 3;
	_tresh = if ((count _this) > 4) then
		{
		(_this select 4)
		}
	else
		{
		-1
		};

	_inRange = [];
	
		{
		_pos = position _x;
		_dst = _center distance _pos;
		
		if (_dst < _maxR) then
			{
			if (_dst > _minR) then
				{
				_inRange pushBack _x
				}
			};
			
		if ((count _inRange) == _tresh) exitWith {};
		}
	foreach _areas;
	
	_inRange
	};
	
RYD_WS_Topo = 
	{
	private ["_center","_range","_nearS","_sumUrban","_sumForest","_sumHills","_sumFlat","_sumGrd","_sUrban","_sForest","_sHill","_sFlat","_sGrd","_cntNS","_urbanF","_forestF","_hillsF","_flatF","_grdF"];

	_center = _this select 0;
	_range = _this select 1;

	_nearS = [_center,RydBB_Sectors,0,_range] call RYD_WS_FindSectorInRange;

	RYD_WS_NearSectors = _nearS;

	_sumUrban = 0;
	_sumForest = 0;
	_sumHills = 0;
	_sumFlat = 0;
	_sumGrd = 0;

		{		
		_sUrban = _x getVariable "Topo_UrbanP";
		_sForest = _x getVariable "Topo_ForestP";
		_sHill = _x getVariable "Topo_HillsP";
		_sFlat = _x getVariable "Topo_FlatP";
		_sGrd = _x getVariable "Topo_GrdP";
		
		_sumUrban = _sumUrban + _sUrban;
		_sumForest = _sumForest + _sForest;
		_sumHills = _sumHills + _sHill;
		_sumFlat = _sumFlat + _sFlat;
		_sumGrd = _sumGrd + _sGrd;
		}
	foreach _nearS;

	_cntNS = (count _nearS) max 1;

	_urbanF = _sumUrban/_cntNS;
	_forestF = _sumForest/_cntNS;
	_hillsF = _sumHills/_cntNS;
	_flatF = _sumFlat/_cntNS;
	_grdF = _sumGrd/_cntNS;

	[_urbanF,_forestF,_hillsF,_flatF,_grdF]
	};
	
RYD_WS_NearSea = 
	{
	private ["_center","_range","_nearS","_sumSea","_sSea","_sumSea","_cntNS","_seaF"];
	
	_center = _this select 0;
	_range = _this select 1;

	_nearS = [_center,RydBB_Sectors,0,_range] call RYD_WS_FindSectorInRange;

	_sumSea = 0;

		{		
		_sSea = _x getVariable "Topo_SeaP";

		_sumSea = _sumSea + _sSea;
		}
	foreach _nearS;

	_cntNS = (count _nearS) max 1;

	_seaF = _sumSea/_cntNS;
	
	_seaF
	};
	
RYD_WS_SpawnGroupSafe = 
	{//based on BIS_fnc_spawnGroup by BI Studio (Joris-Jan van 't Land (modified by Thomas Ryan))
	private ["_pos","_side","_count","_chars","_ranks","_positions","_item","_types","_safePos","_rP","_rnd","_ct","_typesC","_del","_types","_grp","_ourVehs","_type","_relPos","_itemPos","_unit",
	"_newGrp","_am","_maxRank","_rank","_out","_vh","_eP","_unit","_eD","_eG","_eC","_crw","_imp","_ic","_checked","_azimuth","_itemPos0","_fe","_nR","_cl","_pItems","_foundPos"];
		
	_pos = _this select 0;
	_side = _this select 1;
	
	_count = {(side _x) == _side} count allGroups;
	if (_count > 143) exitWith {grpNull};

	_chars = _this select 2;
	
	_ranks = [];
	//_positions = [[0,0,0]];
	_types = [];
	
	for "_ia" from 0 to ((count _chars) - 1) do 
		{
		_item = _chars select _ia;
		
		if (isClass _item) then 
			{
			_types set [(count _types),getText(_item >> "vehicle")];
			_ranks set [(count _ranks),getText(_item >> "rank")];
			
			/*if (_ia > 0) then
				{
				_safePos = [_pos,0,100,12,0,4,0] call BIS_fnc_findSafePos;
				_rP = [(_safePos select 0) - (_pos select 0),(_safePos select 1) - (_pos select 1),0.5];
				_positions set [(count _positions),_rP]
				}*/
			};
		};
	
	_grp = createGroup _side;
	_ourVehs = [];
	_azimuth = _this select 3;
	
	for "_ib" from 0 to ((count _types) - 1) do
		{
		_type = _types select _ib;
		_itemPos0 = +_pos;
		_itemPos = +_itemPos0;
		_foundPos = false;
		
		if (getNumber(configFile >> "CfgVehicles" >> _type >> "isMan") == 1) then 
			{
			_itemPos0 = [_pos,0,160,10,0,4,0] call BIS_fnc_findSafePos;
			_fe = not ((isOnRoad _itemPos0) or not ([_itemPos0] call RYD_WS_isOnMap));
			_nR = _itemPos0 nearRoads 50;
			if ((count _nR) > 0) then {_fe = false};
			
			if (_fe) then
				{
				_cl = [_itemPos0,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
				if (((_cl distance _itemPos0) < 10) or ((_pos distance _itemPos0) > 5000)) then {_fe = false} else {_foundPos = true;_itemPos = _itemPos0}
				};
			
			_ct = 0;
			
			while {(not _fe)} do
				{
				_ct = _ct + 1;
				if (_ct > 20) exitWith {};
				_itemPos = [_itemPos0,10,100 + (_ct * 5)] call RYD_RandomAroundMM;
				_itemPos = [_itemPos,0,160,10,0,4,0] call BIS_fnc_findSafePos;
				_fe = not ((isOnRoad _itemPos) or not ([_itemPos] call RYD_WS_isOnMap));
				_nR = _itemPos nearRoads 50;
				if ((count _nR) > 0) then {_fe = false};
				if (_fe) then
					{
					_cl = [_itemPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
					if (((_cl distance _itemPos) < 10) or ((_pos distance _itemPos) > 5000)) then {_fe = false} else {_foundPos = true}
					};
				};
			}
		else
			{
			_itemPos0 = [_pos,0,200,20,0,6,0] call BIS_fnc_findSafePos;
			_fe = not ((isOnRoad _itemPos0) or not ([_itemPos0] call RYD_WS_isOnMap));
			_nR = _itemPos0 nearRoads 300;
			if ((count _nR) < 1) then {_fe = false};
			
			if (_fe) then
				{
				_cl = [_itemPos0,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
				if (((_cl distance _itemPos0) < 12) or ((_pos distance _itemPos0) > 5000)) then {_fe = false} else {_foundPos = true;_itemPos = _itemPos0}
				};
			
			_ct = 0;
			
			while {(not _fe)} do
				{
				_ct = _ct + 1;
				if (_ct > 50) exitWith {};
				_itemPos = [_itemPos0,10,100 + (_ct * 5)] call RYD_RandomAroundMM;
				_itemPos = [_itemPos,0,200,20 - (_ct/10),0,6,0] call BIS_fnc_findSafePos;
				_fe = not ((isOnRoad _itemPos) or not ([_itemPos] call RYD_WS_isOnMap));
				_nR = _itemPos nearRoads (300 +_ct);
				if ((count _nR) < 1) then {_fe = false};
				if (_fe) then
					{
					_cl = [_itemPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
					if (((_cl distance _itemPos) < 12) or ((_pos distance _itemPos) > 5000)) then {_fe = false} else {_foundPos = true}
					};
				};
				
			//diag_log format ["ct: %1",_ct];
			};
			
		 if not (_foundPos) exitWith {grpNull};
				
		/*if ((count _positions) > 0) then 
			{
			_relPos = _positions select _ib;
			_itemPos = [(_pos select 0) + (_relPos select 0), (_pos select 1) + (_relPos select 1)];
			} 
		else 
			{
			_itemPos = _pos;
			};*/
			
		RYD_WS_SpawnPositions set [(count RYD_WS_SpawnPositions),_itemPos];

		if (getNumber(configFile >> "CfgVehicles" >> _type >> "isMan") == 1) then 
			{	
			_unit = _grp createUnit [_type, _itemPos, [], 0, "NONE"];
			_unit setDir _azimuth;
			} 
		else 
			{
			_unit = ([_itemPos, _azimuth, _type, _grp] call BIS_fnc_spawnVehicle) select 0;
			
			_isTurret = isClass (configfile >> "CfgVehicles" >> _type >> "Turrets" >> "MainTurret");
			
			if (_isTurret) then
				{
				_unit allowCrewInImmobile true
				};
			
			_ourVehs set [(count _ourVehs),_unit];
			};

		if ((count _ranks) > 0) then 
			{
			[_unit,_ranks select _ib] call bis_fnc_setRank;
			};
		};
		
	_grp setFormDir _azimuth;
		
	_newGrp = createGroup _side;
	
	_newGrp setFormDir _azimuth;
	_ct = 0;
	_am = {alive _x} count (units _grp);
	while {(({alive _x} count (units _grp)) > 0)} do 
		{
		_maxRank = -1;
		_unit = objnull;
		
			{
			_rank = rankid _x;
			if (_rank > _maxRank) then 
				{
				_maxRank = _rank;
				_unit = _x
				};
			} 
		foreach units _grp;
		
		[_unit] joinsilent _newGrp;
		
		_ct = _ct + 1;
		if (_ct > (_am + 1)) exitWith {}
		};
		
	_newGrp selectleader (units _newGrp select 0);
	deletegroup _grp;
	
	if ((count (units _newGrp)) < 1) exitWith {grpNull};
	
	if ((random 100) < 30) then
		{
		_pItems = assignedItems (leader _newGrp);
			
		if not (({(toLower _x) in ["nvgoggles","nvgoggles_indep","nvgoggles_opfor"]} count _pItems) > 0) then
			{
			(leader _newGrp) linkItem "NVGoggles_INDEP"
			};
		};
	
		{
		if ((random 100) < 100) then
			{
			_pItems = assignedItems _x;
			
			if not (({(toLower _x) in ["nvgoggles","nvgoggles_indep","nvgoggles_opfor"]} count _pItems) > 0) then
				{
				_pItems = primaryWeaponItems _x;
				if not (({(toLower _x) in ["acc_flashlight","acc_pointer_ir"]} count _pItems) > 0) then
					{
					_x addPrimaryWeaponItem "acc_flashlight"
					}
				}
			}
		}
	foreach (units _newGrp);
	
	_newGrp setVariable ["RYD_WS_OurVehs",_ourVehs];
		
	if ((count _ourVehs) > 0) then
		{
		_out = [];

			{
			if (_x == (vehicle _x)) then
				{
				_out set [(count _out),_x]
				}
			}
		foreach (units _newGrp);
		
		_imp = [+_out] call RYD_WS_SelectImportant;
				
		_unit = objNull;
		_eD = 0;
		_eG = 0;
		_eC = 0;
		
		if ((count _out) > 0) then
			{			
				{
				_vh = _x;
				
				_eD = _vh emptyPositions "Driver";
				_eG = _vh emptyPositions "Gunner";
				_eC = _vh emptyPositions "Commander";
				
				_vh setVariable ["RYD_WS_InitCrew",[_eD,_eG,_eC]];
				
				if (_eD > 0) then
					{
					if (_imp > 0) then
						{
						_unit = _imp select 0;
						_imp = _imp - [_unit];
						_out = _out - [_unit];
						}
					else
						{
						_unit = _out select 0;
						_out = _out - [_unit];						
						};
						
					_unit moveInDriver _vh				
					};
					
				if not ((count _out) > 0) exitWith {};
				
				if (_eG > 0) then
					{
					if ((count _imp) > 0) then
						{
						_unit = _imp select 0;
						_imp = _imp - [_unit];
						_out = _out - [_unit];
						}
					else
						{
						_unit = _out select 0;
						_out = _out - [_unit];						
						};
						
					_unit moveInGunner _vh				
					};
				
				if not ((count _out) > 0) exitWith {};
				
				if (_eC > 0) then
					{
					if ((count _imp) > 0) then
						{
						_unit = _imp select 0;
						_imp = _imp - [_unit];
						_out = _out - [_unit];
						}
					else
						{
						_unit = _out select 0;
						_out = _out - [_unit];						
						};
						
					_unit moveInCommander _vh				
					};
				
				if not ((count _out) > 0) exitWith {};
				
				_eP = _vh emptyPositions "Cargo";
				_ct = _eP;

				while {(_eP > 0)} do
					{
					if ((count _imp) > 0) then
						{
						_unit = _imp select 0;
						_imp = _imp - [_unit];
						_out = _out - [_unit];
						}
					else
						{
						_unit = _out select (floor (random (count _out)));
						_out = _out - [_unit];						
						};
					
					_unit moveInCargo _vh;
					
					if not ((count _out) > 0) exitWith {};
					
					_eP = _vh emptyPositions "Cargo";
					_ct = _ct - 1;
					if (_ct < -2) exitWith {}		
					};
					
				if not ((count _out) > 0) exitWith {};
				}
			foreach _ourVehs;
				
			if ((count _imp) > 0) then
				{
					{
					_vh = _x;
					
					_iC = _vh getVariable ["RYD_WS_InitCrew",[0,0,0]];
					_eD = _iC select 0;
					_eG = _iC select 1;
					_eC = _iC select 2;
										
					if (_eG == 0) then
						{
						_crw = gunner _vh;
						if not (isNull _crw) then
							{
							if not (_crw == (leader _newGrp)) then
								{
								_unit = _imp select 0;
								_imp = _imp - [_unit];
								deleteVehicle _crw;
								_unit moveInGunner _vh
								}
							}					
						};
						
					if not ((count _imp) > 0) exitWith {};

					if (_eC == 0) then
						{
						_crw = commander _vh;
						if not (isNull _crw) then
							{
							if not (_crw == (leader _newGrp)) then
								{
								_unit = _imp select 0;
								_imp = _imp - [_unit];
								deleteVehicle _crw;
								_unit moveInCommander _vh
								}
							}							
						};
						
					if not ((count _imp) > 0) exitWith {};
					
					if (_eD == 0) then
						{
						_crw = driver _vh;
						if not (isNull _crw) then
							{
							if not (_crw == (leader _newGrp)) then
								{
								_unit = _imp select 0;
								_imp = _imp - [_unit];
								deleteVehicle _crw;
								_unit moveInDriver _vh;
								_newGrp addVehicle _vh 
								}
							}					
						};
						
					if not ((count _imp) > 0) exitWith {};
					}
				foreach _ourVehs
				};
			
				{
				if (_x == (vehicle _x)) then
					{
					deleteVehicle _x
					}
				}
			foreach (units _newGrp)
			};
		};
				
	_newGrp setVariable ["RYD_WS_GroupCount",{alive _x} count (units _newGrp)];
	
	[_newGrp] call RYD_WPdel;
	
	if (RYD_WS_Debug) then
		{
		_ic = "EMark_" + (str _newGrp);
		_ic = createMarker [_ic,position (leader _newGrp)];
		_ic setMarkerColor "colorBlue";
		_ic setMarkerShape "ICON";
		_ic setMarkerType "mil_triangle";
		_ic setMarkerSize [0.6,0.6];
		_newGrp setVariable ["mymarker",_ic];
		_ic setMarkerText (str _azimuth);
		};
		
	if ((count _this) < 5) then
		{	
		_checked = [];
		
			{
			_vh = vehicle _x;
			
			if not (_vh in _checked) then
				{
				_checked set [(count _checked),_vh];
				
				if not (_vh == _x) then
					{
						{
						_x enableSimulation false;
						_x hideObject true
						}
					foreach (crew _vh)
					};
				
				_vh enableSimulation false;
				_vh hideObject true
				}
			}
		foreach (units _newGrp);
		};

	_newGrp
	};
	
RYD_WS_SelectImportant = 
	{
	private ["_units","_important"];
	
	_units = _this select 0;
	
	if ((count _units) < 1) exitWith {[]};

	_important = [leader (group (_units select 0))];
		
	_units = _units - [(leader (group (_units select 0)))];
	
		{
		if not (isNull (unitBackPack _x)) then
			{
			_important set [(count _important),_x]
			};
		}
	foreach _units;
	
	_important
	};
	
RYD_WS_WindRose = 
	{
	private ["_dir","_dirName"];
	
	_dir = _this select 0;
	
	if (_dir < 0) then {_dir = _dir + 360};
	
	_dirName = "";
	
	switch (true) do
		{
		case ((_dir >= 337.5) or (_dir < 22.5)) : {_dirName = "north"};
		case ((_dir < 67.5) and (_dir >= 22.5)) : {_dirName = "north-east"};
		case ((_dir < 112.5) and (_dir >= 67.5)) : {_dirName = "east"};
		case ((_dir < 157.5) and (_dir >= 112.5)) : {_dirName = "south-east"};
		case ((_dir < 202.5) and (_dir >= 157.5)) : {_dirName = "south"};
		case ((_dir < 247.5) and (_dir >= 202.5)) : {_dirName = "south-west"};
		case ((_dir < 292.5) and (_dir >= 247.5)) : {_dirName = "west"};
		case ((_dir < 337.5) and (_dir >= 292.5)) : {_dirName = "north-west"};
		};
		
	_dirName = "the " + _dirName;
		
	_dirName
	};
	
RYD_WS_SpawnAir = 
	{
	private ["_pos","_angle","_classPool","_gp","_dst","_checkPos","_fe","_ct","_vh","_posS","_class","_cl"];
	
	_pos = _this select 0;
	_angle = _this select 1;
	_classPool = _this select 2;
	
	_gp = grpNull;
	
	_dst = 300 - (random 200);

	_checkPos = [_pos,0,_dst] call RYD_RandomAroundMM;

	_fe = (count (_checkPos isflatempty [20,0,0.1,10,0,false,objNull])) > 0;
	_nR = _checkPos nearRoads 50;
	if ((count _nR) > 0) then {_fe = false};
	
	if (_fe) then
		{
		_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
		if ((_cl distance _checkPos) < 12) then 
			{
			_fe = false
			}
		else
			{
			_fe = [_checkPos] call RYD_WS_isOnMap;
			}
		};
	
	_ct = 0;
	
	while {(not (_fe) or {isOnRoad _checkPos})} do
		{
		_ct = _ct + 1;
		if (_ct > 50) exitWith {};
		_dst = _dst + 5;
		_checkPos = [_pos,0,_dst] call RYD_RandomAroundMM;

		_fe = (count (_checkPos isflatempty [20,0,0.1,10,0,false,objNull])) > 0;
		_nR = _checkPos nearRoads 50;
		if ((count _nR) > 0) then {_fe = false};
		
		if (_fe) then
			{
			_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
			if ((_cl distance _checkPos) < 12) then 
				{
				_fe = false
				}
			else
				{
				_fe = [_checkPos] call RYD_WS_isOnMap;
				}
			};
		};
		
	if (_fe) then
		{
		_class = _classPool select (floor (random (count _classPool)));
		
		_vh = createVehicle [_class, _checkPos, [], 0, "FLY"];
		
		RYD_WS_SpawnPositions set [(count RYD_WS_SpawnPositions),_checkPos];

		_vh setDir _angle;
		_vh setPos _checkPos;
		_vh setVectorUP (surfaceNormal [_checkPos select 0,_checkPos select 1]);
		
		createVehicleCrew _vh;
		_gp = (group _vh) 
		};
		
	_gp
	};
	
RYD_WS_SpawnStatic = 
	{
	private ["_pos","_angle","_classPool","_gp","_dst","_checkPos","_LOSpos","_isLOS","_fe","_ct","_vh","_posS","_class","_ep","_bags","_cl"];
	
	_pos = _this select 0;
	_angle = _this select 1;
	_classPool = _this select 2;
	
	_gp = grpNull;
	
	_dst = 300 - (random 200);

	_checkPos = [_pos,_angle + 45 - (random 90),_dst] call RYD_PosTowards2D;
	
	_LOSpos = ATLtoASL ([_checkPos,_angle,50] call RYD_PosTowards2D);
	_isLOS = [ATLtoASL _checkPos,_LOSpos,1.5,1.5] call RYD_WS_LOSCheck;
	_fe = (count (_checkPos isflatempty [3,0,0.5,3,0,false,objNull])) > 0;
	
	if (_fe) then
		{
		_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
		if ((_cl distance _checkPos) < 12) then 
			{
			_fe = false
			}
		else
			{
			_fe = [_checkPos] call RYD_WS_isOnMap;
			}
		};
	
	_ct = 0;
	
	while {(not (_isLOS) or not (_fe) or {isOnRoad _checkPos})} do
		{
		_ct = _ct + 1;
		if (_ct > 50) exitWith {};
		_dst = _dst + 5;
		_checkPos = [_pos,_angle + 45 - (random 90),_dst] call RYD_PosTowards2D;
		_checkPos = [_checkPos,0,_ct/2] call RYD_RandomAroundMM;
		_LOSpos = ATLtoASL ([_checkPos,_angle,50] call RYD_PosTowards2D);
		_isLOS = [ATLtoASL _checkPos,_LOSpos,1.5,1.5] call RYD_WS_LOSCheck;
		_fe = (count (_checkPos isFlatEmpty [3,0,0.5,3,0,false,objNull])) > 0;
		
		if (_fe) then
			{
			_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
			if ((_cl distance _checkPos) < 12) then 
				{
				_fe = false
				}
			else
				{
				_fe = [_checkPos] call RYD_WS_isOnMap;
				}
			};
		};
		
	if (_isLOS) then
		{
		if (_fe) then
			{
			_vh = createVehicle ["Land_BagFence_Round_F", _checkPos, [], 0, "NONE"];
			_bags = _vh;
			_vh setDir (_angle + 180);
			_posS = getPos _vh;
			_posS set [2,-0.01];
			_vh setPos _posS;
			_vh setVectorUP (surfaceNormal [_posS select 0,_posS select 1]);
			
			_posS = _vh modelToWorld [0,0.5,0];
			_posS set [2,0];
			
			_LOSpos set [2,1.5];

			_class = _classPool select (floor (random (count _classPool)));
			
			_vh = createVehicle [_class, _posS, [], 0, "NONE"];
			
			RYD_WS_SpawnPositions set [(count RYD_WS_SpawnPositions),_posS];
			
			_vh setDir _angle;
			_vh setPos _posS;
			_vh setVectorUP (surfaceNormal [_posS select 0,_posS select 1]);
			
			createVehicleCrew _vh;
			
				{
				_x doWatch _LOSpos
				}
			foreach (crew _vh);
			
			_gp = (group _vh);
			
			_ep = (ASLtoATL (eyePos _vh)) select 2;
			
			if (_ep < 0.8) then {deleteVehicle _bags};
			}
		};
		
	_gp
	};
	
RYD_WS_SpawnSupport =
	{
	private ["_pos","_angle","_classPool","_gp","_dst","_checkPos","_fe","_ct","_vh","_posS","_class","_cl"];
	
	_pos = _this select 0;
	_angle = _this select 1;
	_classPool = _this select 2;
	
	_gp = grpNull;
	
	_dst = 200 - (random 150);

	_checkPos = [_pos,0,_dst] call RYD_RandomAroundMM;

	_fe = (count (_checkPos isflatempty [6,0,2,10,0,false,objNull])) > 0;
	
	if (_fe) then
		{
		_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
		if ((_cl distance _checkPos) < 12) then 
			{
			_fe = false
			}
		else
			{
			_fe = [_checkPos] call RYD_WS_isOnMap;
			}
		};
	
	_ct = 0;
	
	while {(not (_fe) or {isOnRoad _checkPos})} do
		{
		_ct = _ct + 1;
		if (_ct > 50) exitWith {};
		_dst = _dst + 5;
		_checkPos = [_pos,0,_dst] call RYD_RandomAroundMM;

		_fe = (count (_checkPos isflatempty [6,0,2,10,0,false,objNull])) > 0;
		
		if (_fe) then
			{
			_cl = [_checkPos,RYD_WS_SpawnPositions] call RYD_WS_FindClosest;
			if ((_cl distance _checkPos) < 12) then 
				{
				_fe = false
				}
			else
				{
				_fe = [_checkPos] call RYD_WS_isOnMap;
				}
			};
		};
		
	if (_fe) then
		{
		_class = _classPool select (floor (random (count _classPool)));
		
		_vh = createVehicle [_class, _checkPos, [], 0, "NONE"];
		
		if ((toLower _class) in (RYD_WS_ammo + RHQ_Ammo)) then
			{
			_side = getNumber (configFile >> "CfgVehicles" >> _class >> "side");
			
			_side = switch (_side) do
				{
				case (0) : {east};
				case (1) : {west};
				case (2) : {resistance};
				};

			_magsP = ["1Rnd_HE_Grenade_shell","HandGrenade"];
			_magsS = [];
			_wpClass = configFile >> "CfgWeapons";
			
				{
				if ((side _x) == _side) then
					{
					_wpn = primaryWeapon _x;
					if not (_wpn in [""]) then
						{
						_mgs = getArray (_wpClass >> _wpn >> "magazines");
						
						if ((count _mgs) > 0) then
							{
							_mg = _mgs select 0;
							
							if not (_mg in _magsP) then
								{
								_magsP set [(count _magsP),_mg]
								}
							}
						};
						
					_wpn = secondaryWeapon _x;
					if not (_wpn in [""]) then
						{
						_mgs = getArray (_wpClass >> _wpn >> "magazines");
						
						if ((count _mgs) > 0) then
							{
							_mg = _mgs select 0;
							
							if not (_mg in _magsS) then
								{
								_magsS set [(count _magsS),_mg]
								}
							}
						}
					}
				}
			foreach allUnits;
			
				{
				_vh addMagazineCargo [_x, 100 + (random 40)];
				}
			foreach _magsP;
			
				{
				_vh addMagazineCargo [_x, 32 + (random 24)];
				}
			foreach _magsS;
			};
		
		RYD_WS_SpawnPositions set [(count RYD_WS_SpawnPositions),_checkPos];

		_vh setDir _angle;
		_vh setPos _checkPos;
		_vh setVectorUP (surfaceNormal [_checkPos select 0,_checkPos select 1]);
		
		createVehicleCrew _vh;
		_gp = (group _vh); 
		};
		
	_gp
	};
	
RYD_WS_LOSCheck = 
	{
	private ["_pos1","_pos2","_tint","_lint","_isLOS","_cam","_target","_pX1","_pY1","_pX2","_pY2","_pos1ATL","_pos2ATL","_level1","_level2"];

	_pos1 = _this select 0;
	_pos2 = _this select 1;
	_level1 = _this select 2;
	_level2 = _this select 3;

	_pX1 = _pos1 select 0;
	_pY1 = _pos1 select 1;

	_pX2 = _pos2 select 0;
	_pY2 = _pos2 select 1;
	
	_pos1 = [_pX1,_pY1,(_pos1 select 2) + _level1];
	_pos2 = [_pX2,_pY2,(_pos2 select 2) + _level2];

	_pos1ATL = [_pX1,_pY1,_level1];
	_pos2ATL = [_pX2,_pY2,_level2];

	_cam = objNull;

	if ((count _this) > 4) then {_cam = _this select 4};

	_target = objNull;

	if ((count _this) > 5) then {_target = _this select 5};

	_tint = terrainintersect [_pos1ATL, _pos2ATL]; 
	_lint = lineintersects [_pos1, _pos2,_cam,_target]; 

	_isLOS = true;

	if ((_tint) or (_lint)) then {_isLOS = false};

	_isLOS
	};
	
RYD_WS_NewRole = 
	{
	_pool = +RYD_WS_ForcesA;
	
		{
		switch (true) do
			{
			case (isNil {_x}) : {_pool set [_foreachIndex,0]};
			case not ((typeName _x) in [typename objNull]) : {_pool set [_foreachIndex,0]};
			case (isNull _x) : {_pool set [_foreachIndex,0]};
			case not (alive _x) : {_pool set [_foreachIndex,0]};
			}
		}
	foreach _pool;
	
	_pool = _pool - [0,player];
	
	if ((count _pool) > 0) then
		{
		selectPlayer (_pool select (floor (random (count _pool))));
		}
	};
	
RYD_TerraCognita = 
	{
	private ["_position","_posX","_posY","_radius","_precision","_sourcesCount","_urban","_forest","_hills","_flat","_sea","_valS","_value","_val0","_samples","_sGr","_hprev","_hcurr","_samplePos","_i","_rds"];	

	_position = _this select 0;
	_samples = _this select 1;
	_rds = 100;
	if ((count _this) > 2) then {_rds = _this select 2};

	if not ((typeName _position) == "ARRAY") then {_position = getPosATL _position};

	_posX = _position select 0;
	_posY = _position select 1;

	_radius = 5;
	_precision = 1;
	_sourcesCount = 1;

	_urban = 0;
	_forest = 0;
	_hills = 0;
	_flat = 0;
	_sea = 0;

	_sGr = 0;
	_hprev = getTerrainHeightASL [_posX,_posY];

	for "_i" from 1 to 10 do
		{
		_samplePos = [_posX + ((random (_rds * 2)) - _rds),_posY + ((random (_rds * 2)) - _rds)];
		_hcurr = getTerrainHeightASL _samplePos;
		_sGr = _sGr + abs (_hcurr - _hprev)
		};

	_sGr = _sGr/10;

		{
		_valS = 0;

		for "_i" from 1 to _samples do
			{
			_position = [_posX + (random (_rds/5)) - (_rds/10),_posY + (random (_rds/5)) - (_rds/10)];


			_value = selectBestPlaces [_position,_radius,_x,_precision,_sourcesCount];

			_val0 = _value select 0;
			_val0 = _val0 select 1;

			_valS = _valS + _val0;
			};

		_valS = _valS/_samples;

		switch (_x) do
			{
			case ("Houses") : {_urban = _urban + _valS};
			case ("Trees") : {_forest = _forest + (_valS/3)};
			case ("Forest") : {_forest = _forest + _valS};
			case ("Hills") : {_hills = _hills + _valS};
			case ("Meadow") : {_flat = _flat + _valS};
			case ("Sea") : {_sea = _sea + _valS};
			};
		}
	foreach ["Houses","Trees","Forest","Hills","Meadow","Sea"];

	[_urban,_forest,_hills,_flat,_sea,_sGr]
	};
	
RYD_Sectorize = 
	{
	private ["_ctr","_lng","_ang","_nbr","_EdgeL","_rd","_main","_step","_X1","_Y1","_posX","_posY","_centers","_first",
	"_sectors","_centers2","_Xa","_Ya","_dXa","_dYa","_dst","_ang2","_Xb","_Yb","_dXb","_dYb","_center","_crX","_crY","_crPoint","_sec"];

	_ctr = _this select 0;
	_lng = _this select 1;
	_ang = _this select 2;
	_nbr = _this select 3;

	_EdgeL = _lng/_nbr;
	
	_rd = _lng/2;

	_main = createLocation ["Name", _ctr, _rd, _rd];
	_main setRectangular true;

	_step = _EdgeL;

	_X1 = _ctr select 0;
	_Y1 = _ctr select 1;

	_posX = (_X1 - _rd) + _step/2;
	_posY = (_Y1 - _rd) + _step/2;

	_centers = [[_posX,_posY]];
	_first = false;

	while {(true)} do
		{
		while {(true)} do
			{
			if not (_first) then {_first = true;_posX = _posX + _step};
			if not ([_posX,_PosY] in _main) exitwith {_posX = ((_ctr select 0) - _rd) + _step/2;_first = true};
			_centers set [(count _centers),[_posX,_PosY]];
			_first = false
			};
		_posY = _posY + _step;
		if not ([_posX,_PosY] in _main) exitwith {}
		};

	if not (_ang in [0,90,180,270]) then
		{
		_main setDirection _ang;
		_centers2 = +_centers;
		_centers = [];

			{
			_Xa = _x select 0;
			_Ya = _x select 1;
			_dXa = (_X1 - _Xa);
			_dYa = (_Y1 - _Ya);
			_dst = _ctr distance _x;

			_ang2 = _ang + (_dXa atan2 _dYa);

			_dXb = _dst * (sin _ang2);
			_dYb = _dst * (cos _ang2);

			_Xb = _X1 + _dXb;
			_Yb = _Y1 + _dYb;
			_center = [_Xb,_Yb];
			_centers set [(count _centers),_center]
			}
		foreach _centers2
		};
	
	_sectors = [];

		{
		_crX = _x select 0;
		_crY = _x select 1;
		_crPoint = [_crX,_crY,0];
		_sec = createLocation ["Name", _crPoint, _EdgeL/2, _EdgeL/2];
		_sec setDirection _ang;
		_sec setRectangular true;

		_sectors set [(count _sectors),_sec];
		}
	foreach _centers;

	[_sectors,_main]	
	};
			
RYD_AngTowards = 
	{
	private ["_source0","_target0","_rnd0","_dX0","_dY0","_angleAzimuth0"];
	
	_source0 = _this select 0;
	_target0 = _this select 1;
	_rnd0 = _this select 2;

	_dX0 = (_target0 select 0) - (_source0 select 0);
	_dY0 = (_target0 select 1) - (_source0 select 1);

	_angleAzimuth0 = (_dX0 atan2 _dY0) + (random (_rnd0 * 2)) - _rnd0;

	_angleAzimuth0
	};
	
RYD_PosTowards2D = 
	{
	private ["_source","_distT","_angle","_dXb","_dYb","_px","_py","_pz"];

	_source = _this select 0;
	_angle = _this select 1;
	_distT = _this select 2;

	_dXb = _distT * (sin _angle);
	_dYb = _distT * (cos _angle);

	_px = (_source select 0) + _dXb;
	_py = (_source select 1) + _dYb;

	_pz = getTerrainHeightASL [_px,_py];

	[_px,_py,_pz]
	};
	
RYD_RandomAroundMM = 
	{//based on Muzzleflash' function
	private ["_pos","_xPos","_yPos","_a","_b","_dir","_angle","_mag","_nX","_nY","_temp"];

	_pos = _this select 0;
	_a = _this select 1;
	_b = _this select 2;
	
	_b = _b - _a;

	_xPos = _pos select 0;
	_yPos = _pos select 1;

	_dir = random 360;

	_mag = _a + (sqrt ((random _b) * _b));
	_nX = _mag * (sin _dir);
	_nY = _mag * (cos _dir);

	_pos = [_xPos + _nX, _yPos + _nY,0];  

	_pos	
	};
	
RYD_WPdel = 
	{//[_gp] call RYD_WPdel
	private ["_gp","_count"];

	_gp = _this select 0;

	if (isNil "_gp") exitWith {};
	if (isNull _gp) exitWith {};

	_count = (count (waypoints _gp)) - 1;

	if (_count < 0) exitWith {};

	[_gp, (currentWaypoint _gp)] setWaypointPosition [position (vehicle (leader _gp)), 0];

	while {not (_count < 0)} do
		{
		if (isNull _gp) exitWith {};
		_count = (count (waypoints _gp)) - 1;
		if (_count < 0) exitWith {};
		deleteWaypoint ((waypoints _gp) select _count);
		_count = (count (waypoints _gp)) - 1
		}
	};
	
RYD_WS_FindClosest = 
	{
	private ["_ref","_objects","_closest","_dstMin","_dstAct","_obj"];

	_ref = _this select 0;
	_objects = _this select 1;

	_closest = objNull;

	if ((count _objects) > 0) then 
		{
		_closest = _objects select 0;
		_obj = _closest;
	
		_dstMin = _ref distance _obj;

			{
			_obj = _x;				
			_dstAct = _ref distance _obj;

			if (_dstAct < _dstMin) then
				{
				_closest = _x;
				_dstMin = _dstAct
				}
			}
		foreach _objects
		};

	_closest
	};
	
RYD_WS_MARTASwitch = 
	{
	switch (RYD_WS_Marta) do
		{
		case (false) :
			{
			RYD_WS_Marta = true;
			hint "Military symbols enabled";
			
				/*{
				_x setVariable ["MARTA_showRules",[(RYD_WS_FacA select 1),1,(RYD_WS_FacB select 1),0]];
				}
			foreach RYD_WS_ForcesA;*/
			
			setGroupIconsVisible [true,false];
			};
			
		case (true) :
			{
			RYD_WS_Marta = false;
			hint "Military symbols disabled";
			
				/*{
				_x setVariable ["MARTA_showRules",[(RYD_WS_FacA select 1),-1,(RYD_WS_FacB select 1),-1]];
				}
			foreach RYD_WS_ForcesA;*/
			
			setGroupIconsVisible [false,false];
			};
		}
	};
	
RYD_BIS_fnc_typeText = 
	{
	/*
		Author: Jiri Wainar

		Description:
		Types a structured text on the screen, letter by letter, cursor blinking.

		Parameter(s):
		_this: array containing blocks of text with same structured text formatting

		Remarks:
		* Every text block is an array of text and formatting tag.
		* Blocks don't have to span over whole line.

		Example:

		[
			["CAMP ROGAIN,","<t align = 'center' shadow = '1' size = '0.7' font='PuristaBold'>%1</t>"],
			["RESSUPLY POINT","<t align = 'center' shadow = '1' size = '0.7'>%1</t><br/>"],
			["10 MINUTES LATER ...","<t align = 'center' shadow = '1' size = '1.0'>%1</t><br/>"]

		] spawn BIS_fnc_typeText;
	*/

	#define DELAY_CHARACTER	0.06;
	#define DELAY_CURSOR	0.04;

	private["_data","_posX","_posY","_rootFormat","_toDisplay"];
	private["_blocks","_block","_blockCount","_blockNr","_blockArray","_blockText","_blockTextF","_blockTextF_","_blockFormat","_formats","_inputData","_processedTextF","_char","_cursorInvis","_blinkCounts","_blinkCount"];

	_data 		= [_this, 0, [], [[]]] call BIS_fnc_param;
	_posX 		= [_this, 1, 0, [123]] call BIS_fnc_param;
	_posY 		= [_this, 2, 0, [123]] call BIS_fnc_param;
	_rootFormat 	= [_this, 3, "<t >%1</t>", [""]] call BIS_fnc_param;

	_blockCount = count _data;

	_invisCursor = "<t color ='#00000000' shadow = '0'>_</t>";

	//process the input data
	_blocks 	= [];
	_formats 	= [];
	_blinkCounts 	= [];

	{
		_inputData = _x;

		_block 		= [_inputData, 0, "", [""]] call BIS_fnc_param;
		_format 	= [_inputData, 1, "<t align = 'center' shadow = '1' size = '0.7'>%1</t><br/>", [""]] call BIS_fnc_param;
		_blinkCount 	= [_inputData, 2, 5, [123]] call BIS_fnc_param;

		//convert strings into array of chars
		_blockArray = toArray _block;
		{_blockArray set [_forEachIndex, toString [_x]]} forEach _blockArray;

		_blocks  = _blocks + [_blockArray];
		_formats = _formats + [_format];
		_blinkCounts = _blinkCounts + [_blinkCount];
	}
	forEach _data;

	//do the printing
	_processedTextF  = "";

	{
		_blockArray  = _x;
		_blockNr     = _forEachIndex;
		_blockFormat = _formats select _blockNr;
		_blockText   = "";
		_blockTextF  = "";
		_blockTextF_ = "";

		{
			_char = _x;

			_blockText = _blockText + _char;

			_blockTextF  = format[_blockFormat, _blockText + _invisCursor];
			_blockTextF_ = format[_blockFormat, _blockText + "_"];

			//print the output
			_toDisplay = format[_rootFormat,_processedTextF + _blockTextF_];
			[_toDisplay, _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;

			playSound "ReadoutClick";

			sleep DELAY_CHARACTER;
			_toDisplay = format[_rootFormat,_processedTextF + _blockTextF];
			[_toDisplay, _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;
			sleep DELAY_CURSOR;
		}
		forEach _blockArray;

		_blinkCount = _blinkCounts select _forEachIndex;

		if (_blinkCount > 0) then
		{
			for "_i" from 1 to _blinkCount do
			{
				_toDisplay = format[_rootFormat,_processedTextF + _blockTextF_];
				[_toDisplay, _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;
				sleep DELAY_CHARACTER;
				_toDisplay = format[_rootFormat,_processedTextF + _blockTextF];
				[_toDisplay, _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;
				sleep DELAY_CURSOR;
			};
		};

		//store finished block
		_processedTextF  = _processedTextF + _blockTextF;
	}
	forEach _blocks;
	
	RYD_WS_Typed = true;
	
	sleep 5;

	//clean the screen
	["", _posX, _posY, 5, 0, 0, 90] spawn BIS_fnc_dynamicText;
	};
	
RYD_WS_ClusterMark = 
	{
	private ["_gps","_cl","_brush","_midX","_midY","_cluster","_pos","_center","_pointMax","_dstMax","_ix","_dstAct","_angle","_dstMax2","_mark"];
	
	_gps = _this select 0;
	_cl = _this select 1;
	_brush = _this select 2;
	
	_midX = 0;
	_midY = 0;

	_cluster = [];

		{
		_pos = position (leader _x);
		_pos set [2,0];
		_cluster set [(count _cluster),_pos]
		}
	foreach _gps;

		{
		_midX = _midX + (_x select 0);
		_midY = _midY + (_x select 1);
		}
	foreach _cluster;

	_center = [_midX/(count _cluster),_midY/(count _cluster),0];

	_pointMax = _center;
	_dstMax = 0;
	_ix = 0;

		{
		_dstAct = _center distance _x;
		if (_dstAct > _dstMax) then
			{
			_dstMax = _dstAct;
			_pointMax = _x;
			_ix = _foreachIndex
			}
		}
	foreach _cluster;

	_cluster set [_ix,-1];
	_cluster = _cluster - [-1];

	_angle = [_center,_pointMax,0] call RYD_AngTowards;

	_pointMax = _center;
	_dstMax2 = 0;

		{
		_dstAct = _center distance _x;
		if (_dstAct > _dstMax2) then
			{
			_dstMax2 = _dstAct;
			_pointMax = _x;
			}
		}
	foreach _cluster;

	_mark = ["Per_" + _cl,_center,_cl,"ELLIPSE",[_dstMax,_dstMax2],_angle + 90,1,"FDiagonal",""] call RYD_Marker;
	
	_mark
	};
	
RYD_WS_onHit = 
	{
	private ["_hit"];
	
	_hit = _this select 0;
	
	if (_hit in RYD_WS_Wounded_A) exitWith {};
	
	RYD_WS_Wounded_A set [(count RYD_WS_Wounded_A),_hit];
	};
	
RYD_WS_onDeathA = 
	{
	private ["_kia","_killer","_KIAs"];
	
	_kia = _this select 0;
	_killer = _this select 1;

	if (_killer getVariable ["RYD_WS_Aside",false]) then {_killer setVariable ["RYD_WS_Indicted",true]};
	
	if (_kia in RYD_WS_Killed_A) exitWith {};
	
	RYD_WS_Killed_A set [(count RYD_WS_Killed_A),_kia];
		
	_KIAs = missionNamespace getVariable ["WS_KIA_A",[]];
	
	_KIAs set [(count _KIAs),(_kia getVariable ["WS_myName",name _kia])];
	
	missionNamespace setVariable ["WS_KIA_A",_KIAs];
	};
	
RYD_WS_onDeathB = 
	{
	private ["_kia","_killer","_KIAs"];
	
	_kia = _this select 0;
	_killer = _this select 1;
		
	//diag_log format ["kia: %1 killer: %2, name: %3 real name: %4",_kia,_killer,name _killer,(_killer getVariable ["WS_myName",name _killer])];
	
	if not (_killer getVariable ["RYD_WS_Aside",false]) exitWith {};
	if (_kia in RYD_WS_Killed_B) exitWith {};
	
	RYD_WS_Killed_B set [(count RYD_WS_Killed_B),_kia];
	
	_name = _killer getVariable ["WS_myName",name _killer];
	
	_KIAs = missionNamespace getVariable ["WS_KIA_B" + _name,[_name,0]];
		
	_amnt = _KIAs select 1;
	_amnt = _amnt + 1;
	
	//diag_log format ["Kills: %1",_amnt];
	
	missionNamespace setVariable ["WS_KIA_B" + _name,[_name,_amnt]];
	};
	
RYD_WS_SortByKills =
	{
	private ["_arr","_sorted","_highest","_valMax","_ix","_val"];
	
	_arr = _this select 0;
	
	_sorted = [];
	
	while {(count _arr) > 0} do
		{
		_highest = _arr select 0;
		_valMax = _highest select 1;
		_ix = 0;
		
			{
			_val = _x select 1;
			if (_val > _valMax) then
				{
				_valMax = _val;
				_highest = _x;
				_ix = _foreachIndex
				}
			}
		foreach _arr;
		
		_sorted set [(count _sorted),_highest];
		_arr set [_ix,0];
		_arr = _arr - [0]
		}; 
	
	_sorted
	};
	
RYD_WS_FatigueSwitch = 
	{
	switch (RYD_WS_Fatigue) do
		{
		case (true) : 
			{
			RYD_WS_Fatigue = false;
			
				{
				_x enableFatigue false
				} 
			forEach allUnits;
			
			hint "Fatigue effects disabled"
			};
			
		case (false) : 
			{
			RYD_WS_Fatigue = true;
			
				{
				_x enableFatigue true
				} 
			forEach allUnits;
			
			hint "Fatigue effects enabled"
			};
		};
	};
	
RYD_RandomOrdB = 
	{
	private ["_array","_final","_random","_select"];

	_array = _this select 0;

	_final = [];

	while {((count _array) > 0)} do
		{
		_select = floor (random (count _array));
		_random = _array select _select;
		
		if not (isNil "_random") then 
			{
			_final pushBack _random;
			};
			
		_array = _array - [_random];

		//_array set [_select,"Delete"];
		//_array = _array - ["Delete"]
		};

	_final
	};

RYD_PresentRHQ = 
	{
	private ["_allVehs","_allUnits","_vehClass","_wpClass","_magClass","_ammoClass","_addedU","_addedV","_veh","_vehClass2","_weapons","_hasLaserD","_wpClass2","_type","_mags",
	"_isDriver","_turrets","_mainT","_isArmed","_isAA","_isAT","_weaps","_trt","_wps","_wp","_muzzles","_ammo","_ammoC","_dam","_isCargo"];
	
	RYD_WS_AllClasses = RYD_WS_Inf_class + RYD_WS_Art_class + RYD_WS_HArmor_class + RYD_WS_MArmor_class + RYD_WS_LArmor_class + RYD_WS_Cars_class + RYD_WS_Air_class + RYD_WS_Naval_class + RYD_WS_Static_class + RYD_WS_Support_class + RYD_WS_Other_class;
	//RYD_WS_AllClasses = [];
		
	_allVehs = [];
	
		{
		if ((side _x) in [west,east,resistance]) then
			{
			_vh = toLower (typeOf _x);
			if not (_vh in RYD_WS_AllClasses) then
				{
				RYD_WS_AllClasses pushBack _vh;
				_allVehs pushBack _x
				}
			}
		}
	foreach vehicles;	
	
	_allUnits = [];
	
		{
		if ((side _x) in [west,east,resistance]) then
			{
			_vh = toLower (typeOf _x);
			if not (_vh in RYD_WS_AllClasses) then
				{
				RYD_WS_AllClasses pushBack _vh;
				_allUnits pushBack _x
				}
			}
		}
	foreach allUnits;
	
	_vehClass = configFile >> "CfgVehicles";
	_wpClass = configFile >> "CfgWeapons";
	_magClass = configFile >> "CfgMagazines";
	_ammoClass = configFile >> "CfgAmmo";
	
	_addedU = [];
	_addedV = [];
	
		{
		_veh = toLower (typeOf _x);
		if not (_veh in _addedU) then
			{
			_addedU pushBack _veh;
			RHQ_Inf pushBack _veh;
			
			_vehClass2 = _vehClass >> _veh;

			if ((getNumber (_vehClass2 >> "camouflage")) < 1) then
				{				
				if ((toLower (getText (_vehClass2 >> "textSingular"))) isEqualTo "sniper") then
					{
					RHQ_Snipers pushBack _veh
					}
				else
					{
					_weapons = getArray (_vehClass2 >> "weapons");
					
					RHQ_Recon pushBack _veh;
					
					_hasLaserD = false;
					
						{
						_wpClass = configFile >> "CfgWeapons" >> _x;
						_type = getNumber (_wpClass >> "type");
						
						if (_type == 4096) then
							{
							_cursor = toLower (getText (_wpClass >> "cursor"));
							if (_cursor in ["","emptycursor"]) then 
								{
								_cursor = toLower (getText (_wpClass >> "cursorAim"))
								};

							if (_cursor isEqualTo "laserdesignator") exitWith {_hasLaserD = true}
							};
							
						if (_hasLaserD) exitWith {}
						}
					foreach _weapons;
					
					if (_hasLaserD) then
						{
						RHQ_FO pushBack _veh
						}					
					}
				};
			
			_wps = getArray (_vehClass2 >> "Weapons");

			if ((count _wps) > 1) then
				{
				_isAT = false;
				_isAA = false;
				
					{
					_sWeapon = _x;
					_mgs = configfile >> "CfgWeapons" >> _sWeapon >> "magazines";
					if (isArray _mgs) then
						{
						_mgs = getArray _mgs;

						if ((count _mgs) > 0) then
							{
							_mag = _mgs select 0;
							_ammo = getText (configfile >> "CfgMagazines" >> _mag >> "ammo");
							_ammoC = configfile >> "CfgAmmo" >> _ammo;
							
							_isAA = ((getNumber (_ammoC >> "airLock")) > 1) or {((getNumber (_ammoC >> "airLock")) > 0) and {((getNumber (_ammoC >> "irLock")) > 0)}};
							
							if not (_isAA) then
								{
								_isAT = ((((getNumber (_ammoC >> "irLock")) + (getNumber (_ammoC >> "laserLock"))) > 0) and {((getNumber (_ammoC >> "airLock")) < 2)})
								};
							
							if (not (_isAT) and {not (_isAA)}) then
								{
								
									{
									_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
									_ammoC = configfile >> "CfgAmmo" >> _ammo;
									_actHit = getNumber (_ammoC >> "hit");

									if (_actHit > 150) exitWith {_isAT = true}
									}
								foreach _mgs
								};
							
							if (_isAT) then 
								{
								RHQ_ATInf pushBack _veh
								};
								
							if (_isAA) then  
								{
								RHQ_AAInf pushBack _veh
								};
							}
						};
						
					if ((_isAT) or {(_isAA)}) exitWith {}
					}
				foreach _wps
				}
			}	
		}
	foreach _allUnits;

	_flareMags = ["Laserbatteries","60Rnd_CMFlareMagazine","120Rnd_CMFlareMagazine","240Rnd_CMFlareMagazine","60Rnd_CMFlare_Chaff_Magazine","120Rnd_CMFlare_Chaff_Magazine","240Rnd_CMFlare_Chaff_Magazine","192Rnd_CMFlare_Chaff_Magazine","168Rnd_CMFlare_Chaff_Magazine","300Rnd_CMFlare_Chaff_Magazine"];
	
		{
		_veh = toLower (typeOf _x);
		_vehO = _x;
		if not (_veh in _addedV) then
			{
			_addedV pushBack _veh;
			
			_vehClass2 = _vehClass >> _veh;

			_isDriver = (getNumber (_vehClass2 >> "hasDriver")) > 0;

			_turrets = _vehClass2 >> "Turrets";
			_cT = count _turrets;
			_tMags = [];
			
			if (_cT > 0) then
				{
				for "_i" from 0 to (_cT - 1) do 
					{
					_trt = _turrets select _i;
					if (isClass _trt) then
						{
						_trt = configName _trt;
						_mgT = _vehClass2 >> "Turrets" >> _trt >> "magazines";
						if (isArray _mgT) then
							{
							_tMags = _tMags + (getArray _mgT)
							}
						}
					}
				};

			_mainT = _turrets >> "MainTurret";
			_isMainT = isClass _mainT;
			
			_isAmmoS = (getNumber (_vehClass2 >> "transportAmmo")) > 0;
			_isFuelS = (getNumber (_vehClass2 >> "transportFuel")) > 0;
			_isRepS = (getNumber (_vehClass2 >> "transportRepair")) > 0;
			_isMedS = (getNumber (_vehClass2 >> "attendant")) > 0;
			_mags = getArray (_vehClass2 >> "magazines") + _tMags;			
			_isArmed = (count (_mags - _flareMags)) > 0;
			_isCargo = ((getNumber (_vehClass2 >> "transportSoldier")) > 1) and {((getNumber (_vehClass2 >> "transportAmmo")) + (getNumber (_vehClass2 >> "transportFuel")) + (getNumber (_vehClass2 >> "transportRepair")) + (getNumber (_vehClass2 >> "attendant"))) < 1};
			_isArty = (getNumber (_vehClass2 >> "artilleryScanner")) > 0;
						
			_type = "inf";

			_base = _veh;
			
			while {not (_base in ["air","ship","tank","car","wheeled_apc_f","ugv_01_base_f"])} do
				{
				_base = inheritsFrom (_vehClass >> _base);
				if not (isClass _base) exitWith {};
				_base = toLower (configName _base);
				if (_base in ["allvehicles","all"]) exitWith {};
				};			
			
			if not (_base isEqualTo "ugv_01_base_f") then
				{
				if (_base in ["air","ship","tank","car","wheeled_apc_f"]) then
					{
					_type = _base
					};
				};
				
			if (_isArty) then
				{
				RHQ_Art pushBack _veh;
				
				_prim = "";
				_rare = "";
				_sec = "";
				_smoke = "";
				_illum = "";

				if (_isArmed) then
					{
					_mags = magazines _vehO;
					
					if (_isMainT) then
						{
						_mags = _mags + ((getArray (_mainT >> "magazines")) - _mags)
						};
						
					_maxHit = 10;
					
						{
						_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
						_ammoC = configfile >> "CfgAmmo" >> _ammo;
						
						_actHit = getNumber (_ammoC >> "indirectHitRange");
						_subM = toLower (getText (_ammoC >> "submunitionAmmo"));
												
						if (_actHit <= 10) then
							{
							if not (_subM isEqualTo "") then
								{
								_ammoC = configfile >> "CfgAmmo" >> _subM;
								_actHit = getNumber (_ammoC >> "indirectHitRange")
								}
							};
						
						if ((_actHit > _maxHit) and {_actHit < 100}) then
							{
							_maxHit = _actHit;
							_prim = _x
							}
						}
					foreach _mags;
					
					_mags = _mags - [_prim];
					_mags0 = +_mags;
					_illumChosen = false;
					_smokeChosen = false;
					_rareChosen = false;
					_secChosen = false;
					
						{
						_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
						_ammoC = configfile >> "CfgAmmo" >> _ammo;
						
						_hit = getNumber (_ammoC >> "indirectHit");
						_lc = _ammoC >> "lightColor";
						_sim = toLower (getText (_ammoC >> "simulation"));
						_subM = toLower (getText (_ammoC >> "submunitionAmmo"));
						
						if (_hit <= 10) then
							{
							if not (_subM isEqualTo "") then
								{
								_ammoC = configfile >> "CfgAmmo" >> _subM;
								_hit = getNumber (_ammoC >> "indirectHit")
								}
							};

						switch (true) do
							{
							case ((isArray _lc) and {not (_illumChosen)}) : 
								{
								_illum = _x;
								_mags = _mags - [_x];
								_illumChosen = true
								};
								
							case ((_hit <= 10) and {(_subM isEqualTo "smokeshellarty") and {not (_smokeChosen)}}) : 
								{
								_smoke = _x;
								_mags = _mags - [_x];
								_smokeChosen = true
								};
								
							case ((_sim isEqualTo "shotsubmunitions") and {not (_rareChosen)}) : 
								{
								_rare = _x;
								_mags = _mags - [_x];
								_rareChosen = true
								};
								
							case ((_hit > 10) and {not ((_secChosen) or {(_rare == _x)})})  : 
								{
								_sec = _x;
								_mags = _mags - [_x];
								_secChosen = true
								}
							}
						}
					foreach _mags0;
					
					if (_sec isEqualTo "") then
						{
						_maxHit = 10;
						
							{
							_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
							_ammoC = configfile >> "CfgAmmo" >> _ammo;
							_subAmmo = _ammoC >> "subMunitionAmmo";
							
							if ((isText _subAmmo) and {not ((getText _subAmmo) isEqualTo "")}) then
								{
								_ammoC = configfile >> "CfgAmmo" >> (getText _subAmmo);
								};
								
							_actHit = getNumber (_ammoC >> "indirectHit");
							
							if (_actHit > _maxHit) then
								{
								_maxHit = _actHit;
								_sec = _x
								}
							}
						foreach _mags;
						}
					};
					
				_arr = [_prim,_rare,_sec,_smoke,_illum];
				if (({_x isEqualTo ""} count _arr) < 5) then
					{
					RydHQ_Add_OtherArty pushBack [[_veh],_arr]
					}
				};
			
			if (_isDriver) then
				{
				switch (_type) do
					{
					case ("car") : {RHQ_Cars pushBack _veh};	
					case ("tank") : {RHQ_HArmor pushBack _veh};	
					case ("wheeled_apc_f") : {RHQ_LArmor pushBack _veh};
					case ("air") : 
						{
						RHQ_Air pushBack _veh;

						if not (_isArmed) then
							{
							RHQ_NCAir pushBack _veh;
							};
							
						_isUAV = (getNumber (_vehClass2 >> "Uav")) > 0;
						
						if not (_isUAV) then
							{
							_isUAV = (toLower (getText (_vehClass2 >> "crew"))) in ["b_uav_ai","i_uav_ai","o_uav_ai"];
							};
							
						if (_isUAV) then
							{
							RHQ_RAir pushBack _veh
							}
						};
						
					case ("ship") : {RHQ_Naval pushBack _veh};			
					};
					
				if (_isCargo) then 
					{
					RHQ_Cargo pushBack _veh;
					if not (_isArmed) then
						{
						RHQ_NCCargo pushBack _veh;
						}
					};
										
				RHQ_HArmor = RHQ_HArmor - RHQ_Art;
				
				if (_isArmed) then
					{
					_mags = magazines _vehO;
					
					if (_isMainT) then
						{
						_mags = _mags + ((getArray (_mainT >> "magazines")) - _mags)
						};
					
						{
						_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
						_ammoC = configfile >> "CfgAmmo" >> _ammo;
						
						_isAA = (getNumber (_ammoC >> "airLock")) > 1;
						_isAT = ((((getNumber (_ammoC >> "irLock")) + (getNumber (_ammoC >> "laserLock"))) > 0) and {((getNumber (_ammoC >> "airLock")) < 2)});
						
						if ((_isAA) and {not (_type isEqualTo "air")}) then {RHQ_AAInf pushBack _veh};
						if (_isAT) then 
							{
							if (_type isEqualTo "wheeled_apc_f") then
								{
								RHQ_LArmorAT pushBack _veh
								}
							else
								{
								if (_type isEqualTo "car") then
									{
									RHQ_ATInf pushBack _veh
									}
								}
							};
							
						if ((_isAA) or {(_isAT)}) exitWith {}
						}
					foreach _mags
					}
				}
			else
				{
				if (_isArmed) then
					{
					RHQ_Static pushBack _veh;
					
					_mags = magazines _vehO;
					
					if (_isMainT) then
						{
						_mags = _mags + ((getArray (_mainT >> "magazines")) - _mags)
						};
					
						{
						_ammo = getText (configfile >> "CfgMagazines" >> _x >> "ammo");
						_ammoC = configfile >> "CfgAmmo" >> _ammo;
						
						_isAA = (getNumber (_ammoC >> "airLock")) > 1;
						_isAT = ((((getNumber (_ammoC >> "irLock")) + (getNumber (_ammoC >> "laserLock"))) > 0) and {((getNumber (_ammoC >> "airLock")) < 2)});
						
						if (_isAA) then {RHQ_StaticAA pushBack _veh};
						if (_isAT) then {RHQ_StaticAT pushBack _veh};
							
						if ((_isAA) or {(_isAT)}) exitWith {}
						}
					foreach _mags
					}
				};
				
			if (_isAmmoS) then 
				{
				if not (_veh in RHQ_Ammo) then
					{
					RHQ_Ammo pushBack _veh
					};				

				if not (_veh in RHQ_Support) then
					{
					RHQ_Support pushBack _veh
					}
				};
				
			if (_isFuelS) then 
				{				
				if not (_veh in RHQ_Fuel) then
					{
					RHQ_Fuel pushBack _veh
					};					
				
				if not (_veh in RHQ_Support) then
					{
					RHQ_Support pushBack _veh
					}
				};
				
			if (_isRepS) then 
				{				
				if not (_veh in RHQ_Rep) then
					{
					RHQ_Rep pushBack _veh
					};					
				
				if not (_veh in RHQ_Support) then
					{
					RHQ_Support pushBack _veh
					}
				};
				
			if (_isMedS) then 
				{				
				if not (_veh in RHQ_Med) then
					{
					RHQ_Med pushBack _veh
					};	
				
				if not (_veh in RHQ_Support) then
					{
					RHQ_Support pushBack _veh
					}
				};
				
			if (_type in ["air","tank","wheeled_apc_f"]) then
				{
				_crew = _vehClass >> _veh >> "crew";
				
				if (isText _crew) then
					{
					_crew = toLower (getText _crew);

					if not (_crew in (RYD_WS_Crew_class + RHQ_Crew)) then
						{
						RHQ_Crew pushBack _crew;
						}
					}
				}
			};			
		}
	foreach _allVehs;
	
	RHQ_Inf = RHQ_Inf - ["b_uav_ai","i_uav_ai","o_uav_ai"];
	RHQ_Crew = RHQ_Crew - ["b_uav_ai","i_uav_ai","o_uav_ai"];
	
	true
	};